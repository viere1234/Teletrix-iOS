// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(MatrixSDKCryptoFFI)
import MatrixSDKCryptoFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_f611_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_f611_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol BackupKeysProtocol {
    func `backupVersion`()   -> String
    func `recoveryKey`()   -> BackupRecoveryKey
    
}

public class BackupKeys: BackupKeysProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { _uniffi_matrix_sdk_crypto_ffi_object_free_BackupKeys_7ad1(pointer, $0) }
    }

    

    
    

    public func `backupVersion`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_BackupKeys_backup_version_6a86(self.pointer, $0
    )
}
        )
    }

    public func `recoveryKey`()  -> BackupRecoveryKey {
        return try!  FfiConverterTypeBackupRecoveryKey.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_BackupKeys_recovery_key_2567(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeBackupKeys: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupKeys

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupKeys {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BackupKeys, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupKeys {
        return BackupKeys(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BackupKeys) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeBackupKeys_lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupKeys {
    return try FfiConverterTypeBackupKeys.lift(pointer)
}

public func FfiConverterTypeBackupKeys_lower(_ value: BackupKeys) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBackupKeys.lower(value)
}


public protocol BackupRecoveryKeyProtocol {
    func `decryptV1`(`ephemeralKey`: String, `mac`: String, `ciphertext`: String)  throws -> String
    func `megolmV1PublicKey`()   -> MegolmV1BackupKey
    func `toBase58`()   -> String
    func `toBase64`()   -> String
    
}

public class BackupRecoveryKey: BackupRecoveryKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    matrix_sdk_crypto_ffi_f611_BackupRecoveryKey_new($0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_f611_BackupRecoveryKey_object_free(pointer, $0) }
    }

    

    public static func `fromPassphrase`(`passphrase`: String, `salt`: String, `rounds`: Int32)  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try! rustCall() {
    matrix_sdk_crypto_ffi_f611_BackupRecoveryKey_from_passphrase(
        FfiConverterString.lower(`passphrase`), 
        FfiConverterString.lower(`salt`), 
        FfiConverterInt32.lower(`rounds`), $0)
})
    }

    

    public static func `newFromPassphrase`(`passphrase`: String)  -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try! rustCall() {
    matrix_sdk_crypto_ffi_f611_BackupRecoveryKey_new_from_passphrase(
        FfiConverterString.lower(`passphrase`), $0)
})
    }

    

    public static func `fromBase64`(`key`: String) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeDecodeError.self) {
    matrix_sdk_crypto_ffi_f611_BackupRecoveryKey_from_base64(
        FfiConverterString.lower(`key`), $0)
})
    }

    

    public static func `fromBase58`(`key`: String) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeDecodeError.self) {
    matrix_sdk_crypto_ffi_f611_BackupRecoveryKey_from_base58(
        FfiConverterString.lower(`key`), $0)
})
    }

    

    
    

    public func `decryptV1`(`ephemeralKey`: String, `mac`: String, `ciphertext`: String) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypePkDecryptionError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_BackupRecoveryKey_decrypt_v1_9754(self.pointer, 
        FfiConverterString.lower(`ephemeralKey`), 
        FfiConverterString.lower(`mac`), 
        FfiConverterString.lower(`ciphertext`), $0
    )
}
        )
    }

    public func `megolmV1PublicKey`()  -> MegolmV1BackupKey {
        return try!  FfiConverterTypeMegolmV1BackupKey.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_BackupRecoveryKey_megolm_v1_public_key_1d77(self.pointer, $0
    )
}
        )
    }

    public func `toBase58`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_BackupRecoveryKey_to_base58_3fbd(self.pointer, $0
    )
}
        )
    }

    public func `toBase64`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_BackupRecoveryKey_to_base64_8861(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeBackupRecoveryKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupRecoveryKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupRecoveryKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BackupRecoveryKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupRecoveryKey {
        return BackupRecoveryKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BackupRecoveryKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeBackupRecoveryKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupRecoveryKey {
    return try FfiConverterTypeBackupRecoveryKey.lift(pointer)
}

public func FfiConverterTypeBackupRecoveryKey_lower(_ value: BackupRecoveryKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBackupRecoveryKey.lower(value)
}


public protocol OlmMachineProtocol {
    func `outgoingRequests`()  throws -> [Request]
    func `markRequestAsSent`(`requestId`: String, `requestType`: RequestType, `response`: String)  throws
    func `getIdentity`(`userId`: String, `timeout`: UInt32)  throws -> UserIdentity?
    func `verifyIdentity`(`userId`: String)  throws -> SignatureUploadRequest
    func `getDevice`(`userId`: String, `deviceId`: String, `timeout`: UInt32)  throws -> Device?
    func `setLocalTrust`(`userId`: String, `deviceId`: String, `trustState`: LocalTrust)  throws
    func `verifyDevice`(`userId`: String, `deviceId`: String)  throws -> SignatureUploadRequest
    func `getUserDevices`(`userId`: String, `timeout`: UInt32)  throws -> [Device]
    func `importRoomKeys`(`keys`: String, `passphrase`: String, `progressListener`: ProgressListener)  throws -> KeysImportResult
    func `importDecryptedRoomKeys`(`keys`: String, `progressListener`: ProgressListener)  throws -> KeysImportResult
    func `isIdentityVerified`(`userId`: String)  throws -> Bool
    func `sign`(`message`: String)   -> [String: [String: String]]
    func `verifyBackup`(`authData`: String)  throws -> SignatureVerification
    func `backupEnabled`()   -> Bool
    func `backupRoomKeys`()  throws -> Request?
    func `bootstrapCrossSigning`()  throws -> BootstrapCrossSigningResult
    func `crossSigningStatus`()   -> CrossSigningStatus
    func `decryptRoomEvent`(`event`: String, `roomId`: String, `handleVerificationEvents`: Bool, `strictShields`: Bool)  throws -> DecryptedEvent
    func `deviceId`()   -> String
    func `disableBackup`()  throws
    func `discardRoomKey`(`roomId`: String)  throws
    func `enableBackupV1`(`key`: MegolmV1BackupKey, `version`: String)  throws
    func `encrypt`(`roomId`: String, `eventType`: String, `content`: String)  throws -> String
    func `exportCrossSigningKeys`()   -> CrossSigningKeyExport?
    func `exportRoomKeys`(`passphrase`: String, `rounds`: Int32)  throws -> String
    func `getBackupKeys`()  throws -> BackupKeys?
    func `getMissingSessions`(`users`: [String])  throws -> Request?
    func `getOnlyAllowTrustedDevices`()  throws -> Bool
    func `getRoomSettings`(`roomId`: String)  throws -> RoomSettings?
    func `getVerification`(`userId`: String, `flowId`: String)   -> Verification?
    func `getVerificationRequest`(`userId`: String, `flowId`: String)   -> VerificationRequest?
    func `getVerificationRequests`(`userId`: String)   -> [VerificationRequest]
    func `identityKeys`()   -> [String: String]
    func `importCrossSigningKeys`(`export`: CrossSigningKeyExport)  throws
    func `isUserTracked`(`userId`: String)  throws -> Bool
    func `receiveSyncChanges`(`events`: String, `deviceChanges`: DeviceLists, `keyCounts`: [String: Int32], `unusedFallbackKeys`: [String]?)  throws -> String
    func `receiveUnencryptedVerificationEvent`(`event`: String, `roomId`: String)  throws
    func `receiveVerificationEvent`(`event`: String, `roomId`: String)  throws
    func `requestRoomKey`(`event`: String, `roomId`: String)  throws -> KeyRequestPair
    func `requestSelfVerification`(`methods`: [String])  throws -> RequestVerificationResult?
    func `requestVerification`(`userId`: String, `roomId`: String, `eventId`: String, `methods`: [String])  throws -> VerificationRequest?
    func `requestVerificationWithDevice`(`userId`: String, `deviceId`: String, `methods`: [String])  throws -> RequestVerificationResult?
    func `roomKeyCounts`()  throws -> RoomKeyCounts
    func `saveRecoveryKey`(`key`: BackupRecoveryKey?, `version`: String?)  throws
    func `setOnlyAllowTrustedDevices`(`onlyAllowTrustedDevices`: Bool)  throws
    func `setRoomAlgorithm`(`roomId`: String, `algorithm`: EventEncryptionAlgorithm)  throws
    func `setRoomOnlyAllowTrustedDevices`(`roomId`: String, `onlyAllowTrustedDevices`: Bool)  throws
    func `shareRoomKey`(`roomId`: String, `users`: [String], `settings`: EncryptionSettings)  throws -> [Request]
    func `startSasWithDevice`(`userId`: String, `deviceId`: String)  throws -> StartSasResult?
    func `updateTrackedUsers`(`users`: [String])  throws
    func `userId`()   -> String
    func `verificationRequestContent`(`userId`: String, `methods`: [String])  throws -> String?
    
}

public class OlmMachine: OlmMachineProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`userId`: String, `deviceId`: String, `path`: String, `passphrase`: String?) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_new(
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), 
        FfiConverterString.lower(`path`), 
        FfiConverterOptionString.lower(`passphrase`), $0)
})
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_f611_OlmMachine_object_free(pointer, $0) }
    }

    

    
    

    public func `outgoingRequests`() throws -> [Request] {
        return try  FfiConverterSequenceTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_outgoing_requests(self.pointer, $0
    )
}
        )
    }

    public func `markRequestAsSent`(`requestId`: String, `requestType`: RequestType, `response`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_mark_request_as_sent(self.pointer, 
        FfiConverterString.lower(`requestId`), 
        FfiConverterTypeRequestType.lower(`requestType`), 
        FfiConverterString.lower(`response`), $0
    )
}
    }

    public func `getIdentity`(`userId`: String, `timeout`: UInt32) throws -> UserIdentity? {
        return try  FfiConverterOptionTypeUserIdentity.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_get_identity(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterUInt32.lower(`timeout`), $0
    )
}
        )
    }

    public func `verifyIdentity`(`userId`: String) throws -> SignatureUploadRequest {
        return try  FfiConverterTypeSignatureUploadRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeSignatureError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_verify_identity(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `getDevice`(`userId`: String, `deviceId`: String, `timeout`: UInt32) throws -> Device? {
        return try  FfiConverterOptionTypeDevice.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_get_device(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), 
        FfiConverterUInt32.lower(`timeout`), $0
    )
}
        )
    }

    public func `setLocalTrust`(`userId`: String, `deviceId`: String, `trustState`: LocalTrust) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_set_local_trust(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), 
        FfiConverterTypeLocalTrust.lower(`trustState`), $0
    )
}
    }

    public func `verifyDevice`(`userId`: String, `deviceId`: String) throws -> SignatureUploadRequest {
        return try  FfiConverterTypeSignatureUploadRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeSignatureError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_verify_device(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), $0
    )
}
        )
    }

    public func `getUserDevices`(`userId`: String, `timeout`: UInt32) throws -> [Device] {
        return try  FfiConverterSequenceTypeDevice.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_get_user_devices(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterUInt32.lower(`timeout`), $0
    )
}
        )
    }

    public func `importRoomKeys`(`keys`: String, `passphrase`: String, `progressListener`: ProgressListener) throws -> KeysImportResult {
        return try  FfiConverterTypeKeysImportResult.lift(
            try 
    rustCallWithError(FfiConverterTypeKeyImportError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_import_room_keys(self.pointer, 
        FfiConverterString.lower(`keys`), 
        FfiConverterString.lower(`passphrase`), 
        FfiConverterCallbackInterfaceProgressListener.lower(`progressListener`), $0
    )
}
        )
    }

    public func `importDecryptedRoomKeys`(`keys`: String, `progressListener`: ProgressListener) throws -> KeysImportResult {
        return try  FfiConverterTypeKeysImportResult.lift(
            try 
    rustCallWithError(FfiConverterTypeKeyImportError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_import_decrypted_room_keys(self.pointer, 
        FfiConverterString.lower(`keys`), 
        FfiConverterCallbackInterfaceProgressListener.lower(`progressListener`), $0
    )
}
        )
    }

    public func `isIdentityVerified`(`userId`: String) throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_is_identity_verified(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `sign`(`message`: String)  -> [String: [String: String]] {
        return try!  FfiConverterDictionaryStringDictionaryStringString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_OlmMachine_sign(self.pointer, 
        FfiConverterString.lower(`message`), $0
    )
}
        )
    }

    public func `verifyBackup`(`authData`: String) throws -> SignatureVerification {
        return try  FfiConverterTypeSignatureVerification.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_OlmMachine_verify_backup(self.pointer, 
        FfiConverterString.lower(`authData`), $0
    )
}
        )
    }

    public func `backupEnabled`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_backup_enabled_18b9(self.pointer, $0
    )
}
        )
    }

    public func `backupRoomKeys`() throws -> Request? {
        return try  FfiConverterOptionTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_backup_room_keys_e0d8(self.pointer, $0
    )
}
        )
    }

    public func `bootstrapCrossSigning`() throws -> BootstrapCrossSigningResult {
        return try  FfiConverterTypeBootstrapCrossSigningResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_bootstrap_cross_signing_379(self.pointer, $0
    )
}
        )
    }

    public func `crossSigningStatus`()  -> CrossSigningStatus {
        return try!  FfiConverterTypeCrossSigningStatus.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_cross_signing_status_e4ae(self.pointer, $0
    )
}
        )
    }

    public func `decryptRoomEvent`(`event`: String, `roomId`: String, `handleVerificationEvents`: Bool, `strictShields`: Bool) throws -> DecryptedEvent {
        return try  FfiConverterTypeDecryptedEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeDecryptionError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_decrypt_room_event_4f4f(self.pointer, 
        FfiConverterString.lower(`event`), 
        FfiConverterString.lower(`roomId`), 
        FfiConverterBool.lower(`handleVerificationEvents`), 
        FfiConverterBool.lower(`strictShields`), $0
    )
}
        )
    }

    public func `deviceId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_device_id_efde(self.pointer, $0
    )
}
        )
    }

    public func `disableBackup`() throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_disable_backup_ac9f(self.pointer, $0
    )
}
    }

    public func `discardRoomKey`(`roomId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_discard_room_key_ac56(self.pointer, 
        FfiConverterString.lower(`roomId`), $0
    )
}
    }

    public func `enableBackupV1`(`key`: MegolmV1BackupKey, `version`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeDecodeError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_enable_backup_v1_a0a2(self.pointer, 
        FfiConverterTypeMegolmV1BackupKey.lower(`key`), 
        FfiConverterString.lower(`version`), $0
    )
}
    }

    public func `encrypt`(`roomId`: String, `eventType`: String, `content`: String) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_encrypt_63b1(self.pointer, 
        FfiConverterString.lower(`roomId`), 
        FfiConverterString.lower(`eventType`), 
        FfiConverterString.lower(`content`), $0
    )
}
        )
    }

    public func `exportCrossSigningKeys`()  -> CrossSigningKeyExport? {
        return try!  FfiConverterOptionTypeCrossSigningKeyExport.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_export_cross_signing_keys_47bf(self.pointer, $0
    )
}
        )
    }

    public func `exportRoomKeys`(`passphrase`: String, `rounds`: Int32) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_export_room_keys_937c(self.pointer, 
        FfiConverterString.lower(`passphrase`), 
        FfiConverterInt32.lower(`rounds`), $0
    )
}
        )
    }

    public func `getBackupKeys`() throws -> BackupKeys? {
        return try  FfiConverterOptionTypeBackupKeys.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_get_backup_keys_d873(self.pointer, $0
    )
}
        )
    }

    public func `getMissingSessions`(`users`: [String]) throws -> Request? {
        return try  FfiConverterOptionTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_get_missing_sessions_e0ed(self.pointer, 
        FfiConverterSequenceString.lower(`users`), $0
    )
}
        )
    }

    public func `getOnlyAllowTrustedDevices`() throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_get_only_allow_trusted_devices_4c8(self.pointer, $0
    )
}
        )
    }

    public func `getRoomSettings`(`roomId`: String) throws -> RoomSettings? {
        return try  FfiConverterOptionTypeRoomSettings.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_get_room_settings_2ef3(self.pointer, 
        FfiConverterString.lower(`roomId`), $0
    )
}
        )
    }

    public func `getVerification`(`userId`: String, `flowId`: String)  -> Verification? {
        return try!  FfiConverterOptionTypeVerification.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_get_verification_18fa(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }

    public func `getVerificationRequest`(`userId`: String, `flowId`: String)  -> VerificationRequest? {
        return try!  FfiConverterOptionTypeVerificationRequest.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_get_verification_request_a81d(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`flowId`), $0
    )
}
        )
    }

    public func `getVerificationRequests`(`userId`: String)  -> [VerificationRequest] {
        return try!  FfiConverterSequenceTypeVerificationRequest.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_get_verification_requests_9571(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `identityKeys`()  -> [String: String] {
        return try!  FfiConverterDictionaryStringString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_identity_keys_705c(self.pointer, $0
    )
}
        )
    }

    public func `importCrossSigningKeys`(`export`: CrossSigningKeyExport) throws {
        try 
    rustCallWithError(FfiConverterTypeSecretImportError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_import_cross_signing_keys_7223(self.pointer, 
        FfiConverterTypeCrossSigningKeyExport.lower(`export`), $0
    )
}
    }

    public func `isUserTracked`(`userId`: String) throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_is_user_tracked_fa20(self.pointer, 
        FfiConverterString.lower(`userId`), $0
    )
}
        )
    }

    public func `receiveSyncChanges`(`events`: String, `deviceChanges`: DeviceLists, `keyCounts`: [String: Int32], `unusedFallbackKeys`: [String]?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_receive_sync_changes_a0bf(self.pointer, 
        FfiConverterString.lower(`events`), 
        FfiConverterTypeDeviceLists.lower(`deviceChanges`), 
        FfiConverterDictionaryStringInt32.lower(`keyCounts`), 
        FfiConverterOptionSequenceString.lower(`unusedFallbackKeys`), $0
    )
}
        )
    }

    public func `receiveUnencryptedVerificationEvent`(`event`: String, `roomId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_receive_unencrypted_verification_event_1ccd(self.pointer, 
        FfiConverterString.lower(`event`), 
        FfiConverterString.lower(`roomId`), $0
    )
}
    }

    public func `receiveVerificationEvent`(`event`: String, `roomId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_receive_verification_event_8215(self.pointer, 
        FfiConverterString.lower(`event`), 
        FfiConverterString.lower(`roomId`), $0
    )
}
    }

    public func `requestRoomKey`(`event`: String, `roomId`: String) throws -> KeyRequestPair {
        return try  FfiConverterTypeKeyRequestPair.lift(
            try 
    rustCallWithError(FfiConverterTypeDecryptionError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_request_room_key_85db(self.pointer, 
        FfiConverterString.lower(`event`), 
        FfiConverterString.lower(`roomId`), $0
    )
}
        )
    }

    public func `requestSelfVerification`(`methods`: [String]) throws -> RequestVerificationResult? {
        return try  FfiConverterOptionTypeRequestVerificationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_request_self_verification_8b29(self.pointer, 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }

    public func `requestVerification`(`userId`: String, `roomId`: String, `eventId`: String, `methods`: [String]) throws -> VerificationRequest? {
        return try  FfiConverterOptionTypeVerificationRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_request_verification_32bd(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`roomId`), 
        FfiConverterString.lower(`eventId`), 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }

    public func `requestVerificationWithDevice`(`userId`: String, `deviceId`: String, `methods`: [String]) throws -> RequestVerificationResult? {
        return try  FfiConverterOptionTypeRequestVerificationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_request_verification_with_device_11bb(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }

    public func `roomKeyCounts`() throws -> RoomKeyCounts {
        return try  FfiConverterTypeRoomKeyCounts.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_room_key_counts_de1b(self.pointer, $0
    )
}
        )
    }

    public func `saveRecoveryKey`(`key`: BackupRecoveryKey?, `version`: String?) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_save_recovery_key_c6c9(self.pointer, 
        FfiConverterOptionTypeBackupRecoveryKey.lower(`key`), 
        FfiConverterOptionString.lower(`version`), $0
    )
}
    }

    public func `setOnlyAllowTrustedDevices`(`onlyAllowTrustedDevices`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_set_only_allow_trusted_devices_279e(self.pointer, 
        FfiConverterBool.lower(`onlyAllowTrustedDevices`), $0
    )
}
    }

    public func `setRoomAlgorithm`(`roomId`: String, `algorithm`: EventEncryptionAlgorithm) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_set_room_algorithm_6f69(self.pointer, 
        FfiConverterString.lower(`roomId`), 
        FfiConverterTypeEventEncryptionAlgorithm.lower(`algorithm`), $0
    )
}
    }

    public func `setRoomOnlyAllowTrustedDevices`(`roomId`: String, `onlyAllowTrustedDevices`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_set_room_only_allow_trusted_devices_adfe(self.pointer, 
        FfiConverterString.lower(`roomId`), 
        FfiConverterBool.lower(`onlyAllowTrustedDevices`), $0
    )
}
    }

    public func `shareRoomKey`(`roomId`: String, `users`: [String], `settings`: EncryptionSettings) throws -> [Request] {
        return try  FfiConverterSequenceTypeRequest.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_share_room_key_11c0(self.pointer, 
        FfiConverterString.lower(`roomId`), 
        FfiConverterSequenceString.lower(`users`), 
        FfiConverterTypeEncryptionSettings.lower(`settings`), $0
    )
}
        )
    }

    public func `startSasWithDevice`(`userId`: String, `deviceId`: String) throws -> StartSasResult? {
        return try  FfiConverterOptionTypeStartSasResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_start_sas_with_device_1aae(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterString.lower(`deviceId`), $0
    )
}
        )
    }

    public func `updateTrackedUsers`(`users`: [String]) throws {
        try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_update_tracked_users_408f(self.pointer, 
        FfiConverterSequenceString.lower(`users`), $0
    )
}
    }

    public func `userId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_user_id_4573(self.pointer, $0
    )
}
        )
    }

    public func `verificationRequestContent`(`userId`: String, `methods`: [String]) throws -> String? {
        return try  FfiConverterOptionString.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    _uniffi_matrix_sdk_crypto_ffi_impl_OlmMachine_verification_request_content_7099(self.pointer, 
        FfiConverterString.lower(`userId`), 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }
}



public struct FfiConverterTypeOlmMachine: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OlmMachine

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OlmMachine {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OlmMachine, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OlmMachine {
        return OlmMachine(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OlmMachine) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOlmMachine_lift(_ pointer: UnsafeMutableRawPointer) throws -> OlmMachine {
    return try FfiConverterTypeOlmMachine.lift(pointer)
}

public func FfiConverterTypeOlmMachine_lower(_ value: OlmMachine) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOlmMachine.lower(value)
}


public protocol QrCodeProtocol {
    func `otherUserId`()   -> String
    func `otherDeviceId`()   -> String
    func `flowId`()   -> String
    func `roomId`()   -> String?
    func `weStarted`()   -> Bool
    func `isDone`()   -> Bool
    func `isCancelled`()   -> Bool
    func `cancelInfo`()   -> CancelInfo?
    func `reciprocated`()   -> Bool
    func `hasBeenScanned`()   -> Bool
    func `confirm`()   -> ConfirmVerificationResult?
    func `cancel`(`cancelCode`: String)   -> OutgoingVerificationRequest?
    func `generateQrCode`()   -> String?
    func `setChangesListener`(`listener`: QrCodeListener)  
    func `state`()   -> QrCodeState
    
}

public class QrCode: QrCodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_f611_QrCode_object_free(pointer, $0) }
    }

    

    
    

    public func `otherUserId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_other_user_id(self.pointer, $0
    )
}
        )
    }

    public func `otherDeviceId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_other_device_id(self.pointer, $0
    )
}
        )
    }

    public func `flowId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_flow_id(self.pointer, $0
    )
}
        )
    }

    public func `roomId`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_room_id(self.pointer, $0
    )
}
        )
    }

    public func `weStarted`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_we_started(self.pointer, $0
    )
}
        )
    }

    public func `isDone`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_is_done(self.pointer, $0
    )
}
        )
    }

    public func `isCancelled`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_is_cancelled(self.pointer, $0
    )
}
        )
    }

    public func `cancelInfo`()  -> CancelInfo? {
        return try!  FfiConverterOptionTypeCancelInfo.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_cancel_info(self.pointer, $0
    )
}
        )
    }

    public func `reciprocated`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_reciprocated(self.pointer, $0
    )
}
        )
    }

    public func `hasBeenScanned`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_has_been_scanned(self.pointer, $0
    )
}
        )
    }

    public func `confirm`()  -> ConfirmVerificationResult? {
        return try!  FfiConverterOptionTypeConfirmVerificationResult.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_confirm(self.pointer, $0
    )
}
        )
    }

    public func `cancel`(`cancelCode`: String)  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_cancel(self.pointer, 
        FfiConverterString.lower(`cancelCode`), $0
    )
}
        )
    }

    public func `generateQrCode`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_generate_qr_code(self.pointer, $0
    )
}
        )
    }

    public func `setChangesListener`(`listener`: QrCodeListener)  {
        try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_set_changes_listener(self.pointer, 
        FfiConverterCallbackInterfaceQrCodeListener.lower(`listener`), $0
    )
}
    }

    public func `state`()  -> QrCodeState {
        return try!  FfiConverterTypeQrCodeState.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_QrCode_state(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeQrCode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = QrCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: QrCode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> QrCode {
        return QrCode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: QrCode) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeQrCode_lift(_ pointer: UnsafeMutableRawPointer) throws -> QrCode {
    return try FfiConverterTypeQrCode.lift(pointer)
}

public func FfiConverterTypeQrCode_lower(_ value: QrCode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeQrCode.lower(value)
}


public protocol SasProtocol {
    func `otherUserId`()   -> String
    func `otherDeviceId`()   -> String
    func `flowId`()   -> String
    func `roomId`()   -> String?
    func `weStarted`()   -> Bool
    func `isDone`()   -> Bool
    func `accept`()   -> OutgoingVerificationRequest?
    func `confirm`()  throws -> ConfirmVerificationResult?
    func `cancel`(`cancelCode`: String)   -> OutgoingVerificationRequest?
    func `getEmojiIndices`()   -> [Int32]?
    func `getDecimals`()   -> [Int32]?
    func `setChangesListener`(`listener`: SasListener)  
    func `state`()   -> SasState
    
}

public class Sas: SasProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_f611_Sas_object_free(pointer, $0) }
    }

    

    
    

    public func `otherUserId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_other_user_id(self.pointer, $0
    )
}
        )
    }

    public func `otherDeviceId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_other_device_id(self.pointer, $0
    )
}
        )
    }

    public func `flowId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_flow_id(self.pointer, $0
    )
}
        )
    }

    public func `roomId`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_room_id(self.pointer, $0
    )
}
        )
    }

    public func `weStarted`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_we_started(self.pointer, $0
    )
}
        )
    }

    public func `isDone`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_is_done(self.pointer, $0
    )
}
        )
    }

    public func `accept`()  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_accept(self.pointer, $0
    )
}
        )
    }

    public func `confirm`() throws -> ConfirmVerificationResult? {
        return try  FfiConverterOptionTypeConfirmVerificationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_Sas_confirm(self.pointer, $0
    )
}
        )
    }

    public func `cancel`(`cancelCode`: String)  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_cancel(self.pointer, 
        FfiConverterString.lower(`cancelCode`), $0
    )
}
        )
    }

    public func `getEmojiIndices`()  -> [Int32]? {
        return try!  FfiConverterOptionSequenceInt32.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_get_emoji_indices(self.pointer, $0
    )
}
        )
    }

    public func `getDecimals`()  -> [Int32]? {
        return try!  FfiConverterOptionSequenceInt32.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_get_decimals(self.pointer, $0
    )
}
        )
    }

    public func `setChangesListener`(`listener`: SasListener)  {
        try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_set_changes_listener(self.pointer, 
        FfiConverterCallbackInterfaceSasListener.lower(`listener`), $0
    )
}
    }

    public func `state`()  -> SasState {
        return try!  FfiConverterTypeSasState.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Sas_state(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeSas: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Sas

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Sas {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Sas, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Sas {
        return Sas(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Sas) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeSas_lift(_ pointer: UnsafeMutableRawPointer) throws -> Sas {
    return try FfiConverterTypeSas.lift(pointer)
}

public func FfiConverterTypeSas_lower(_ value: Sas) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSas.lower(value)
}


public protocol VerificationProtocol {
    func `asQr`()   -> QrCode?
    func `asSas`()   -> Sas?
    
}

public class Verification: VerificationProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_f611_Verification_object_free(pointer, $0) }
    }

    

    
    

    public func `asQr`()  -> QrCode? {
        return try!  FfiConverterOptionTypeQrCode.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Verification_as_qr(self.pointer, $0
    )
}
        )
    }

    public func `asSas`()  -> Sas? {
        return try!  FfiConverterOptionTypeSas.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_Verification_as_sas(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeVerification: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Verification

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Verification {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Verification, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Verification {
        return Verification(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Verification) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeVerification_lift(_ pointer: UnsafeMutableRawPointer) throws -> Verification {
    return try FfiConverterTypeVerification.lift(pointer)
}

public func FfiConverterTypeVerification_lower(_ value: Verification) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVerification.lower(value)
}


public protocol VerificationRequestProtocol {
    func `otherUserId`()   -> String
    func `otherDeviceId`()   -> String?
    func `flowId`()   -> String
    func `roomId`()   -> String?
    func `weStarted`()   -> Bool
    func `isReady`()   -> Bool
    func `isDone`()   -> Bool
    func `isPassive`()   -> Bool
    func `isCancelled`()   -> Bool
    func `cancelInfo`()   -> CancelInfo?
    func `theirSupportedMethods`()   -> [String]?
    func `ourSupportedMethods`()   -> [String]?
    func `accept`(`methods`: [String])   -> OutgoingVerificationRequest?
    func `startSasVerification`()  throws -> StartSasResult?
    func `startQrVerification`()  throws -> QrCode?
    func `scanQrCode`(`data`: String)   -> ScanResult?
    func `cancel`()   -> OutgoingVerificationRequest?
    func `setChangesListener`(`listener`: VerificationRequestListener)  
    func `state`()   -> VerificationRequestState
    
}

public class VerificationRequest: VerificationRequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_matrix_sdk_crypto_ffi_f611_VerificationRequest_object_free(pointer, $0) }
    }

    

    
    

    public func `otherUserId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_other_user_id(self.pointer, $0
    )
}
        )
    }

    public func `otherDeviceId`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_other_device_id(self.pointer, $0
    )
}
        )
    }

    public func `flowId`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_flow_id(self.pointer, $0
    )
}
        )
    }

    public func `roomId`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_room_id(self.pointer, $0
    )
}
        )
    }

    public func `weStarted`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_we_started(self.pointer, $0
    )
}
        )
    }

    public func `isReady`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_is_ready(self.pointer, $0
    )
}
        )
    }

    public func `isDone`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_is_done(self.pointer, $0
    )
}
        )
    }

    public func `isPassive`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_is_passive(self.pointer, $0
    )
}
        )
    }

    public func `isCancelled`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_is_cancelled(self.pointer, $0
    )
}
        )
    }

    public func `cancelInfo`()  -> CancelInfo? {
        return try!  FfiConverterOptionTypeCancelInfo.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_cancel_info(self.pointer, $0
    )
}
        )
    }

    public func `theirSupportedMethods`()  -> [String]? {
        return try!  FfiConverterOptionSequenceString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_their_supported_methods(self.pointer, $0
    )
}
        )
    }

    public func `ourSupportedMethods`()  -> [String]? {
        return try!  FfiConverterOptionSequenceString.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_our_supported_methods(self.pointer, $0
    )
}
        )
    }

    public func `accept`(`methods`: [String])  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_accept(self.pointer, 
        FfiConverterSequenceString.lower(`methods`), $0
    )
}
        )
    }

    public func `startSasVerification`() throws -> StartSasResult? {
        return try  FfiConverterOptionTypeStartSasResult.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_VerificationRequest_start_sas_verification(self.pointer, $0
    )
}
        )
    }

    public func `startQrVerification`() throws -> QrCode? {
        return try  FfiConverterOptionTypeQrCode.lift(
            try 
    rustCallWithError(FfiConverterTypeCryptoStoreError.self) {
    matrix_sdk_crypto_ffi_f611_VerificationRequest_start_qr_verification(self.pointer, $0
    )
}
        )
    }

    public func `scanQrCode`(`data`: String)  -> ScanResult? {
        return try!  FfiConverterOptionTypeScanResult.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_scan_qr_code(self.pointer, 
        FfiConverterString.lower(`data`), $0
    )
}
        )
    }

    public func `cancel`()  -> OutgoingVerificationRequest? {
        return try!  FfiConverterOptionTypeOutgoingVerificationRequest.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_cancel(self.pointer, $0
    )
}
        )
    }

    public func `setChangesListener`(`listener`: VerificationRequestListener)  {
        try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_set_changes_listener(self.pointer, 
        FfiConverterCallbackInterfaceVerificationRequestListener.lower(`listener`), $0
    )
}
    }

    public func `state`()  -> VerificationRequestState {
        return try!  FfiConverterTypeVerificationRequestState.lift(
            try! 
    rustCall() {
    
    matrix_sdk_crypto_ffi_f611_VerificationRequest_state(self.pointer, $0
    )
}
        )
    }
}



public struct FfiConverterTypeVerificationRequest: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = VerificationRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: VerificationRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> VerificationRequest {
        return VerificationRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: VerificationRequest) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeVerificationRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> VerificationRequest {
    return try FfiConverterTypeVerificationRequest.lift(pointer)
}

public func FfiConverterTypeVerificationRequest_lower(_ value: VerificationRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVerificationRequest.lower(value)
}


public struct BootstrapCrossSigningResult {
    public var `uploadSigningKeysRequest`: UploadSigningKeysRequest
    public var `signatureRequest`: SignatureUploadRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`uploadSigningKeysRequest`: UploadSigningKeysRequest, `signatureRequest`: SignatureUploadRequest) {
        self.`uploadSigningKeysRequest` = `uploadSigningKeysRequest`
        self.`signatureRequest` = `signatureRequest`
    }
}


extension BootstrapCrossSigningResult: Equatable, Hashable {
    public static func ==(lhs: BootstrapCrossSigningResult, rhs: BootstrapCrossSigningResult) -> Bool {
        if lhs.`uploadSigningKeysRequest` != rhs.`uploadSigningKeysRequest` {
            return false
        }
        if lhs.`signatureRequest` != rhs.`signatureRequest` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`uploadSigningKeysRequest`)
        hasher.combine(`signatureRequest`)
    }
}


public struct FfiConverterTypeBootstrapCrossSigningResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BootstrapCrossSigningResult {
        return try BootstrapCrossSigningResult(
            `uploadSigningKeysRequest`: FfiConverterTypeUploadSigningKeysRequest.read(from: &buf), 
            `signatureRequest`: FfiConverterTypeSignatureUploadRequest.read(from: &buf)
        )
    }

    public static func write(_ value: BootstrapCrossSigningResult, into buf: inout [UInt8]) {
        FfiConverterTypeUploadSigningKeysRequest.write(value.`uploadSigningKeysRequest`, into: &buf)
        FfiConverterTypeSignatureUploadRequest.write(value.`signatureRequest`, into: &buf)
    }
}


public func FfiConverterTypeBootstrapCrossSigningResult_lift(_ buf: RustBuffer) throws -> BootstrapCrossSigningResult {
    return try FfiConverterTypeBootstrapCrossSigningResult.lift(buf)
}

public func FfiConverterTypeBootstrapCrossSigningResult_lower(_ value: BootstrapCrossSigningResult) -> RustBuffer {
    return FfiConverterTypeBootstrapCrossSigningResult.lower(value)
}


public struct CancelInfo {
    public var `cancelCode`: String
    public var `reason`: String
    public var `cancelledByUs`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`cancelCode`: String, `reason`: String, `cancelledByUs`: Bool) {
        self.`cancelCode` = `cancelCode`
        self.`reason` = `reason`
        self.`cancelledByUs` = `cancelledByUs`
    }
}


extension CancelInfo: Equatable, Hashable {
    public static func ==(lhs: CancelInfo, rhs: CancelInfo) -> Bool {
        if lhs.`cancelCode` != rhs.`cancelCode` {
            return false
        }
        if lhs.`reason` != rhs.`reason` {
            return false
        }
        if lhs.`cancelledByUs` != rhs.`cancelledByUs` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`cancelCode`)
        hasher.combine(`reason`)
        hasher.combine(`cancelledByUs`)
    }
}


public struct FfiConverterTypeCancelInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CancelInfo {
        return try CancelInfo(
            `cancelCode`: FfiConverterString.read(from: &buf), 
            `reason`: FfiConverterString.read(from: &buf), 
            `cancelledByUs`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CancelInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`cancelCode`, into: &buf)
        FfiConverterString.write(value.`reason`, into: &buf)
        FfiConverterBool.write(value.`cancelledByUs`, into: &buf)
    }
}


public func FfiConverterTypeCancelInfo_lift(_ buf: RustBuffer) throws -> CancelInfo {
    return try FfiConverterTypeCancelInfo.lift(buf)
}

public func FfiConverterTypeCancelInfo_lower(_ value: CancelInfo) -> RustBuffer {
    return FfiConverterTypeCancelInfo.lower(value)
}


public struct ConfirmVerificationResult {
    public var `requests`: [OutgoingVerificationRequest]
    public var `signatureRequest`: SignatureUploadRequest?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`requests`: [OutgoingVerificationRequest], `signatureRequest`: SignatureUploadRequest?) {
        self.`requests` = `requests`
        self.`signatureRequest` = `signatureRequest`
    }
}


extension ConfirmVerificationResult: Equatable, Hashable {
    public static func ==(lhs: ConfirmVerificationResult, rhs: ConfirmVerificationResult) -> Bool {
        if lhs.`requests` != rhs.`requests` {
            return false
        }
        if lhs.`signatureRequest` != rhs.`signatureRequest` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`requests`)
        hasher.combine(`signatureRequest`)
    }
}


public struct FfiConverterTypeConfirmVerificationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmVerificationResult {
        return try ConfirmVerificationResult(
            `requests`: FfiConverterSequenceTypeOutgoingVerificationRequest.read(from: &buf), 
            `signatureRequest`: FfiConverterOptionTypeSignatureUploadRequest.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmVerificationResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeOutgoingVerificationRequest.write(value.`requests`, into: &buf)
        FfiConverterOptionTypeSignatureUploadRequest.write(value.`signatureRequest`, into: &buf)
    }
}


public func FfiConverterTypeConfirmVerificationResult_lift(_ buf: RustBuffer) throws -> ConfirmVerificationResult {
    return try FfiConverterTypeConfirmVerificationResult.lift(buf)
}

public func FfiConverterTypeConfirmVerificationResult_lower(_ value: ConfirmVerificationResult) -> RustBuffer {
    return FfiConverterTypeConfirmVerificationResult.lower(value)
}


public struct CrossSigningKeyExport {
    public var `masterKey`: String?
    public var `selfSigningKey`: String?
    public var `userSigningKey`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`masterKey`: String?, `selfSigningKey`: String?, `userSigningKey`: String?) {
        self.`masterKey` = `masterKey`
        self.`selfSigningKey` = `selfSigningKey`
        self.`userSigningKey` = `userSigningKey`
    }
}


extension CrossSigningKeyExport: Equatable, Hashable {
    public static func ==(lhs: CrossSigningKeyExport, rhs: CrossSigningKeyExport) -> Bool {
        if lhs.`masterKey` != rhs.`masterKey` {
            return false
        }
        if lhs.`selfSigningKey` != rhs.`selfSigningKey` {
            return false
        }
        if lhs.`userSigningKey` != rhs.`userSigningKey` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`masterKey`)
        hasher.combine(`selfSigningKey`)
        hasher.combine(`userSigningKey`)
    }
}


public struct FfiConverterTypeCrossSigningKeyExport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CrossSigningKeyExport {
        return try CrossSigningKeyExport(
            `masterKey`: FfiConverterOptionString.read(from: &buf), 
            `selfSigningKey`: FfiConverterOptionString.read(from: &buf), 
            `userSigningKey`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CrossSigningKeyExport, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`masterKey`, into: &buf)
        FfiConverterOptionString.write(value.`selfSigningKey`, into: &buf)
        FfiConverterOptionString.write(value.`userSigningKey`, into: &buf)
    }
}


public func FfiConverterTypeCrossSigningKeyExport_lift(_ buf: RustBuffer) throws -> CrossSigningKeyExport {
    return try FfiConverterTypeCrossSigningKeyExport.lift(buf)
}

public func FfiConverterTypeCrossSigningKeyExport_lower(_ value: CrossSigningKeyExport) -> RustBuffer {
    return FfiConverterTypeCrossSigningKeyExport.lower(value)
}


public struct CrossSigningStatus {
    public var `hasMaster`: Bool
    public var `hasSelfSigning`: Bool
    public var `hasUserSigning`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`hasMaster`: Bool, `hasSelfSigning`: Bool, `hasUserSigning`: Bool) {
        self.`hasMaster` = `hasMaster`
        self.`hasSelfSigning` = `hasSelfSigning`
        self.`hasUserSigning` = `hasUserSigning`
    }
}


extension CrossSigningStatus: Equatable, Hashable {
    public static func ==(lhs: CrossSigningStatus, rhs: CrossSigningStatus) -> Bool {
        if lhs.`hasMaster` != rhs.`hasMaster` {
            return false
        }
        if lhs.`hasSelfSigning` != rhs.`hasSelfSigning` {
            return false
        }
        if lhs.`hasUserSigning` != rhs.`hasUserSigning` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`hasMaster`)
        hasher.combine(`hasSelfSigning`)
        hasher.combine(`hasUserSigning`)
    }
}


public struct FfiConverterTypeCrossSigningStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CrossSigningStatus {
        return try CrossSigningStatus(
            `hasMaster`: FfiConverterBool.read(from: &buf), 
            `hasSelfSigning`: FfiConverterBool.read(from: &buf), 
            `hasUserSigning`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CrossSigningStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`hasMaster`, into: &buf)
        FfiConverterBool.write(value.`hasSelfSigning`, into: &buf)
        FfiConverterBool.write(value.`hasUserSigning`, into: &buf)
    }
}


public func FfiConverterTypeCrossSigningStatus_lift(_ buf: RustBuffer) throws -> CrossSigningStatus {
    return try FfiConverterTypeCrossSigningStatus.lift(buf)
}

public func FfiConverterTypeCrossSigningStatus_lower(_ value: CrossSigningStatus) -> RustBuffer {
    return FfiConverterTypeCrossSigningStatus.lower(value)
}


public struct DecryptedEvent {
    public var `clearEvent`: String
    public var `senderCurve25519Key`: String
    public var `claimedEd25519Key`: String?
    public var `forwardingCurve25519Chain`: [String]
    public var `shieldState`: ShieldState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`clearEvent`: String, `senderCurve25519Key`: String, `claimedEd25519Key`: String?, `forwardingCurve25519Chain`: [String], `shieldState`: ShieldState) {
        self.`clearEvent` = `clearEvent`
        self.`senderCurve25519Key` = `senderCurve25519Key`
        self.`claimedEd25519Key` = `claimedEd25519Key`
        self.`forwardingCurve25519Chain` = `forwardingCurve25519Chain`
        self.`shieldState` = `shieldState`
    }
}


extension DecryptedEvent: Equatable, Hashable {
    public static func ==(lhs: DecryptedEvent, rhs: DecryptedEvent) -> Bool {
        if lhs.`clearEvent` != rhs.`clearEvent` {
            return false
        }
        if lhs.`senderCurve25519Key` != rhs.`senderCurve25519Key` {
            return false
        }
        if lhs.`claimedEd25519Key` != rhs.`claimedEd25519Key` {
            return false
        }
        if lhs.`forwardingCurve25519Chain` != rhs.`forwardingCurve25519Chain` {
            return false
        }
        if lhs.`shieldState` != rhs.`shieldState` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`clearEvent`)
        hasher.combine(`senderCurve25519Key`)
        hasher.combine(`claimedEd25519Key`)
        hasher.combine(`forwardingCurve25519Chain`)
        hasher.combine(`shieldState`)
    }
}


public struct FfiConverterTypeDecryptedEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptedEvent {
        return try DecryptedEvent(
            `clearEvent`: FfiConverterString.read(from: &buf), 
            `senderCurve25519Key`: FfiConverterString.read(from: &buf), 
            `claimedEd25519Key`: FfiConverterOptionString.read(from: &buf), 
            `forwardingCurve25519Chain`: FfiConverterSequenceString.read(from: &buf), 
            `shieldState`: FfiConverterTypeShieldState.read(from: &buf)
        )
    }

    public static func write(_ value: DecryptedEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`clearEvent`, into: &buf)
        FfiConverterString.write(value.`senderCurve25519Key`, into: &buf)
        FfiConverterOptionString.write(value.`claimedEd25519Key`, into: &buf)
        FfiConverterSequenceString.write(value.`forwardingCurve25519Chain`, into: &buf)
        FfiConverterTypeShieldState.write(value.`shieldState`, into: &buf)
    }
}


public func FfiConverterTypeDecryptedEvent_lift(_ buf: RustBuffer) throws -> DecryptedEvent {
    return try FfiConverterTypeDecryptedEvent.lift(buf)
}

public func FfiConverterTypeDecryptedEvent_lower(_ value: DecryptedEvent) -> RustBuffer {
    return FfiConverterTypeDecryptedEvent.lower(value)
}


public struct Device {
    public var `userId`: String
    public var `deviceId`: String
    public var `keys`: [String: String]
    public var `algorithms`: [String]
    public var `displayName`: String?
    public var `isBlocked`: Bool
    public var `locallyTrusted`: Bool
    public var `crossSigningTrusted`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`userId`: String, `deviceId`: String, `keys`: [String: String], `algorithms`: [String], `displayName`: String?, `isBlocked`: Bool, `locallyTrusted`: Bool, `crossSigningTrusted`: Bool) {
        self.`userId` = `userId`
        self.`deviceId` = `deviceId`
        self.`keys` = `keys`
        self.`algorithms` = `algorithms`
        self.`displayName` = `displayName`
        self.`isBlocked` = `isBlocked`
        self.`locallyTrusted` = `locallyTrusted`
        self.`crossSigningTrusted` = `crossSigningTrusted`
    }
}


extension Device: Equatable, Hashable {
    public static func ==(lhs: Device, rhs: Device) -> Bool {
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`deviceId` != rhs.`deviceId` {
            return false
        }
        if lhs.`keys` != rhs.`keys` {
            return false
        }
        if lhs.`algorithms` != rhs.`algorithms` {
            return false
        }
        if lhs.`displayName` != rhs.`displayName` {
            return false
        }
        if lhs.`isBlocked` != rhs.`isBlocked` {
            return false
        }
        if lhs.`locallyTrusted` != rhs.`locallyTrusted` {
            return false
        }
        if lhs.`crossSigningTrusted` != rhs.`crossSigningTrusted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`userId`)
        hasher.combine(`deviceId`)
        hasher.combine(`keys`)
        hasher.combine(`algorithms`)
        hasher.combine(`displayName`)
        hasher.combine(`isBlocked`)
        hasher.combine(`locallyTrusted`)
        hasher.combine(`crossSigningTrusted`)
    }
}


public struct FfiConverterTypeDevice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Device {
        return try Device(
            `userId`: FfiConverterString.read(from: &buf), 
            `deviceId`: FfiConverterString.read(from: &buf), 
            `keys`: FfiConverterDictionaryStringString.read(from: &buf), 
            `algorithms`: FfiConverterSequenceString.read(from: &buf), 
            `displayName`: FfiConverterOptionString.read(from: &buf), 
            `isBlocked`: FfiConverterBool.read(from: &buf), 
            `locallyTrusted`: FfiConverterBool.read(from: &buf), 
            `crossSigningTrusted`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Device, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterString.write(value.`deviceId`, into: &buf)
        FfiConverterDictionaryStringString.write(value.`keys`, into: &buf)
        FfiConverterSequenceString.write(value.`algorithms`, into: &buf)
        FfiConverterOptionString.write(value.`displayName`, into: &buf)
        FfiConverterBool.write(value.`isBlocked`, into: &buf)
        FfiConverterBool.write(value.`locallyTrusted`, into: &buf)
        FfiConverterBool.write(value.`crossSigningTrusted`, into: &buf)
    }
}


public func FfiConverterTypeDevice_lift(_ buf: RustBuffer) throws -> Device {
    return try FfiConverterTypeDevice.lift(buf)
}

public func FfiConverterTypeDevice_lower(_ value: Device) -> RustBuffer {
    return FfiConverterTypeDevice.lower(value)
}


public struct DeviceLists {
    public var `changed`: [String]
    public var `left`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`changed`: [String], `left`: [String]) {
        self.`changed` = `changed`
        self.`left` = `left`
    }
}


extension DeviceLists: Equatable, Hashable {
    public static func ==(lhs: DeviceLists, rhs: DeviceLists) -> Bool {
        if lhs.`changed` != rhs.`changed` {
            return false
        }
        if lhs.`left` != rhs.`left` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`changed`)
        hasher.combine(`left`)
    }
}


public struct FfiConverterTypeDeviceLists: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceLists {
        return try DeviceLists(
            `changed`: FfiConverterSequenceString.read(from: &buf), 
            `left`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceLists, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.`changed`, into: &buf)
        FfiConverterSequenceString.write(value.`left`, into: &buf)
    }
}


public func FfiConverterTypeDeviceLists_lift(_ buf: RustBuffer) throws -> DeviceLists {
    return try FfiConverterTypeDeviceLists.lift(buf)
}

public func FfiConverterTypeDeviceLists_lower(_ value: DeviceLists) -> RustBuffer {
    return FfiConverterTypeDeviceLists.lower(value)
}


public struct EncryptionSettings {
    public var `algorithm`: EventEncryptionAlgorithm
    public var `rotationPeriod`: UInt64
    public var `rotationPeriodMsgs`: UInt64
    public var `historyVisibility`: HistoryVisibility
    public var `onlyAllowTrustedDevices`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`algorithm`: EventEncryptionAlgorithm, `rotationPeriod`: UInt64, `rotationPeriodMsgs`: UInt64, `historyVisibility`: HistoryVisibility, `onlyAllowTrustedDevices`: Bool) {
        self.`algorithm` = `algorithm`
        self.`rotationPeriod` = `rotationPeriod`
        self.`rotationPeriodMsgs` = `rotationPeriodMsgs`
        self.`historyVisibility` = `historyVisibility`
        self.`onlyAllowTrustedDevices` = `onlyAllowTrustedDevices`
    }
}


extension EncryptionSettings: Equatable, Hashable {
    public static func ==(lhs: EncryptionSettings, rhs: EncryptionSettings) -> Bool {
        if lhs.`algorithm` != rhs.`algorithm` {
            return false
        }
        if lhs.`rotationPeriod` != rhs.`rotationPeriod` {
            return false
        }
        if lhs.`rotationPeriodMsgs` != rhs.`rotationPeriodMsgs` {
            return false
        }
        if lhs.`historyVisibility` != rhs.`historyVisibility` {
            return false
        }
        if lhs.`onlyAllowTrustedDevices` != rhs.`onlyAllowTrustedDevices` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`algorithm`)
        hasher.combine(`rotationPeriod`)
        hasher.combine(`rotationPeriodMsgs`)
        hasher.combine(`historyVisibility`)
        hasher.combine(`onlyAllowTrustedDevices`)
    }
}


public struct FfiConverterTypeEncryptionSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionSettings {
        return try EncryptionSettings(
            `algorithm`: FfiConverterTypeEventEncryptionAlgorithm.read(from: &buf), 
            `rotationPeriod`: FfiConverterUInt64.read(from: &buf), 
            `rotationPeriodMsgs`: FfiConverterUInt64.read(from: &buf), 
            `historyVisibility`: FfiConverterTypeHistoryVisibility.read(from: &buf), 
            `onlyAllowTrustedDevices`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: EncryptionSettings, into buf: inout [UInt8]) {
        FfiConverterTypeEventEncryptionAlgorithm.write(value.`algorithm`, into: &buf)
        FfiConverterUInt64.write(value.`rotationPeriod`, into: &buf)
        FfiConverterUInt64.write(value.`rotationPeriodMsgs`, into: &buf)
        FfiConverterTypeHistoryVisibility.write(value.`historyVisibility`, into: &buf)
        FfiConverterBool.write(value.`onlyAllowTrustedDevices`, into: &buf)
    }
}


public func FfiConverterTypeEncryptionSettings_lift(_ buf: RustBuffer) throws -> EncryptionSettings {
    return try FfiConverterTypeEncryptionSettings.lift(buf)
}

public func FfiConverterTypeEncryptionSettings_lower(_ value: EncryptionSettings) -> RustBuffer {
    return FfiConverterTypeEncryptionSettings.lower(value)
}


public struct KeyRequestPair {
    public var `cancellation`: Request?
    public var `keyRequest`: Request

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`cancellation`: Request?, `keyRequest`: Request) {
        self.`cancellation` = `cancellation`
        self.`keyRequest` = `keyRequest`
    }
}


extension KeyRequestPair: Equatable, Hashable {
    public static func ==(lhs: KeyRequestPair, rhs: KeyRequestPair) -> Bool {
        if lhs.`cancellation` != rhs.`cancellation` {
            return false
        }
        if lhs.`keyRequest` != rhs.`keyRequest` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`cancellation`)
        hasher.combine(`keyRequest`)
    }
}


public struct FfiConverterTypeKeyRequestPair: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyRequestPair {
        return try KeyRequestPair(
            `cancellation`: FfiConverterOptionTypeRequest.read(from: &buf), 
            `keyRequest`: FfiConverterTypeRequest.read(from: &buf)
        )
    }

    public static func write(_ value: KeyRequestPair, into buf: inout [UInt8]) {
        FfiConverterOptionTypeRequest.write(value.`cancellation`, into: &buf)
        FfiConverterTypeRequest.write(value.`keyRequest`, into: &buf)
    }
}


public func FfiConverterTypeKeyRequestPair_lift(_ buf: RustBuffer) throws -> KeyRequestPair {
    return try FfiConverterTypeKeyRequestPair.lift(buf)
}

public func FfiConverterTypeKeyRequestPair_lower(_ value: KeyRequestPair) -> RustBuffer {
    return FfiConverterTypeKeyRequestPair.lower(value)
}


public struct KeysImportResult {
    public var `imported`: Int64
    public var `total`: Int64
    public var `keys`: [String: [String: [String]]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`imported`: Int64, `total`: Int64, `keys`: [String: [String: [String]]]) {
        self.`imported` = `imported`
        self.`total` = `total`
        self.`keys` = `keys`
    }
}


extension KeysImportResult: Equatable, Hashable {
    public static func ==(lhs: KeysImportResult, rhs: KeysImportResult) -> Bool {
        if lhs.`imported` != rhs.`imported` {
            return false
        }
        if lhs.`total` != rhs.`total` {
            return false
        }
        if lhs.`keys` != rhs.`keys` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`imported`)
        hasher.combine(`total`)
        hasher.combine(`keys`)
    }
}


public struct FfiConverterTypeKeysImportResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeysImportResult {
        return try KeysImportResult(
            `imported`: FfiConverterInt64.read(from: &buf), 
            `total`: FfiConverterInt64.read(from: &buf), 
            `keys`: FfiConverterDictionaryStringDictionaryStringSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: KeysImportResult, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.`imported`, into: &buf)
        FfiConverterInt64.write(value.`total`, into: &buf)
        FfiConverterDictionaryStringDictionaryStringSequenceString.write(value.`keys`, into: &buf)
    }
}


public func FfiConverterTypeKeysImportResult_lift(_ buf: RustBuffer) throws -> KeysImportResult {
    return try FfiConverterTypeKeysImportResult.lift(buf)
}

public func FfiConverterTypeKeysImportResult_lower(_ value: KeysImportResult) -> RustBuffer {
    return FfiConverterTypeKeysImportResult.lower(value)
}


public struct MegolmV1BackupKey {
    public var `publicKey`: String
    public var `signatures`: [String: [String: String]]
    public var `passphraseInfo`: PassphraseInfo?
    public var `backupAlgorithm`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`publicKey`: String, `signatures`: [String: [String: String]], `passphraseInfo`: PassphraseInfo?, `backupAlgorithm`: String) {
        self.`publicKey` = `publicKey`
        self.`signatures` = `signatures`
        self.`passphraseInfo` = `passphraseInfo`
        self.`backupAlgorithm` = `backupAlgorithm`
    }
}


extension MegolmV1BackupKey: Equatable, Hashable {
    public static func ==(lhs: MegolmV1BackupKey, rhs: MegolmV1BackupKey) -> Bool {
        if lhs.`publicKey` != rhs.`publicKey` {
            return false
        }
        if lhs.`signatures` != rhs.`signatures` {
            return false
        }
        if lhs.`passphraseInfo` != rhs.`passphraseInfo` {
            return false
        }
        if lhs.`backupAlgorithm` != rhs.`backupAlgorithm` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`publicKey`)
        hasher.combine(`signatures`)
        hasher.combine(`passphraseInfo`)
        hasher.combine(`backupAlgorithm`)
    }
}


public struct FfiConverterTypeMegolmV1BackupKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MegolmV1BackupKey {
        return try MegolmV1BackupKey(
            `publicKey`: FfiConverterString.read(from: &buf), 
            `signatures`: FfiConverterDictionaryStringDictionaryStringString.read(from: &buf), 
            `passphraseInfo`: FfiConverterOptionTypePassphraseInfo.read(from: &buf), 
            `backupAlgorithm`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MegolmV1BackupKey, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`publicKey`, into: &buf)
        FfiConverterDictionaryStringDictionaryStringString.write(value.`signatures`, into: &buf)
        FfiConverterOptionTypePassphraseInfo.write(value.`passphraseInfo`, into: &buf)
        FfiConverterString.write(value.`backupAlgorithm`, into: &buf)
    }
}


public func FfiConverterTypeMegolmV1BackupKey_lift(_ buf: RustBuffer) throws -> MegolmV1BackupKey {
    return try FfiConverterTypeMegolmV1BackupKey.lift(buf)
}

public func FfiConverterTypeMegolmV1BackupKey_lower(_ value: MegolmV1BackupKey) -> RustBuffer {
    return FfiConverterTypeMegolmV1BackupKey.lower(value)
}


public struct MigrationData {
    public var `account`: PickledAccount
    public var `sessions`: [PickledSession]
    public var `inboundGroupSessions`: [PickledInboundGroupSession]
    public var `backupVersion`: String?
    public var `backupRecoveryKey`: String?
    public var `pickleKey`: [UInt8]
    public var `crossSigning`: CrossSigningKeyExport
    public var `trackedUsers`: [String]
    public var `roomSettings`: [String: RoomSettings]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`account`: PickledAccount, `sessions`: [PickledSession], `inboundGroupSessions`: [PickledInboundGroupSession], `backupVersion`: String?, `backupRecoveryKey`: String?, `pickleKey`: [UInt8], `crossSigning`: CrossSigningKeyExport, `trackedUsers`: [String], `roomSettings`: [String: RoomSettings]) {
        self.`account` = `account`
        self.`sessions` = `sessions`
        self.`inboundGroupSessions` = `inboundGroupSessions`
        self.`backupVersion` = `backupVersion`
        self.`backupRecoveryKey` = `backupRecoveryKey`
        self.`pickleKey` = `pickleKey`
        self.`crossSigning` = `crossSigning`
        self.`trackedUsers` = `trackedUsers`
        self.`roomSettings` = `roomSettings`
    }
}


extension MigrationData: Equatable, Hashable {
    public static func ==(lhs: MigrationData, rhs: MigrationData) -> Bool {
        if lhs.`account` != rhs.`account` {
            return false
        }
        if lhs.`sessions` != rhs.`sessions` {
            return false
        }
        if lhs.`inboundGroupSessions` != rhs.`inboundGroupSessions` {
            return false
        }
        if lhs.`backupVersion` != rhs.`backupVersion` {
            return false
        }
        if lhs.`backupRecoveryKey` != rhs.`backupRecoveryKey` {
            return false
        }
        if lhs.`pickleKey` != rhs.`pickleKey` {
            return false
        }
        if lhs.`crossSigning` != rhs.`crossSigning` {
            return false
        }
        if lhs.`trackedUsers` != rhs.`trackedUsers` {
            return false
        }
        if lhs.`roomSettings` != rhs.`roomSettings` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`account`)
        hasher.combine(`sessions`)
        hasher.combine(`inboundGroupSessions`)
        hasher.combine(`backupVersion`)
        hasher.combine(`backupRecoveryKey`)
        hasher.combine(`pickleKey`)
        hasher.combine(`crossSigning`)
        hasher.combine(`trackedUsers`)
        hasher.combine(`roomSettings`)
    }
}


public struct FfiConverterTypeMigrationData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MigrationData {
        return try MigrationData(
            `account`: FfiConverterTypePickledAccount.read(from: &buf), 
            `sessions`: FfiConverterSequenceTypePickledSession.read(from: &buf), 
            `inboundGroupSessions`: FfiConverterSequenceTypePickledInboundGroupSession.read(from: &buf), 
            `backupVersion`: FfiConverterOptionString.read(from: &buf), 
            `backupRecoveryKey`: FfiConverterOptionString.read(from: &buf), 
            `pickleKey`: FfiConverterSequenceUInt8.read(from: &buf), 
            `crossSigning`: FfiConverterTypeCrossSigningKeyExport.read(from: &buf), 
            `trackedUsers`: FfiConverterSequenceString.read(from: &buf), 
            `roomSettings`: FfiConverterDictionaryStringTypeRoomSettings.read(from: &buf)
        )
    }

    public static func write(_ value: MigrationData, into buf: inout [UInt8]) {
        FfiConverterTypePickledAccount.write(value.`account`, into: &buf)
        FfiConverterSequenceTypePickledSession.write(value.`sessions`, into: &buf)
        FfiConverterSequenceTypePickledInboundGroupSession.write(value.`inboundGroupSessions`, into: &buf)
        FfiConverterOptionString.write(value.`backupVersion`, into: &buf)
        FfiConverterOptionString.write(value.`backupRecoveryKey`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`pickleKey`, into: &buf)
        FfiConverterTypeCrossSigningKeyExport.write(value.`crossSigning`, into: &buf)
        FfiConverterSequenceString.write(value.`trackedUsers`, into: &buf)
        FfiConverterDictionaryStringTypeRoomSettings.write(value.`roomSettings`, into: &buf)
    }
}


public func FfiConverterTypeMigrationData_lift(_ buf: RustBuffer) throws -> MigrationData {
    return try FfiConverterTypeMigrationData.lift(buf)
}

public func FfiConverterTypeMigrationData_lower(_ value: MigrationData) -> RustBuffer {
    return FfiConverterTypeMigrationData.lower(value)
}


public struct PassphraseInfo {
    public var `privateKeySalt`: String
    public var `privateKeyIterations`: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`privateKeySalt`: String, `privateKeyIterations`: Int32) {
        self.`privateKeySalt` = `privateKeySalt`
        self.`privateKeyIterations` = `privateKeyIterations`
    }
}


extension PassphraseInfo: Equatable, Hashable {
    public static func ==(lhs: PassphraseInfo, rhs: PassphraseInfo) -> Bool {
        if lhs.`privateKeySalt` != rhs.`privateKeySalt` {
            return false
        }
        if lhs.`privateKeyIterations` != rhs.`privateKeyIterations` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`privateKeySalt`)
        hasher.combine(`privateKeyIterations`)
    }
}


public struct FfiConverterTypePassphraseInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PassphraseInfo {
        return try PassphraseInfo(
            `privateKeySalt`: FfiConverterString.read(from: &buf), 
            `privateKeyIterations`: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: PassphraseInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`privateKeySalt`, into: &buf)
        FfiConverterInt32.write(value.`privateKeyIterations`, into: &buf)
    }
}


public func FfiConverterTypePassphraseInfo_lift(_ buf: RustBuffer) throws -> PassphraseInfo {
    return try FfiConverterTypePassphraseInfo.lift(buf)
}

public func FfiConverterTypePassphraseInfo_lower(_ value: PassphraseInfo) -> RustBuffer {
    return FfiConverterTypePassphraseInfo.lower(value)
}


public struct PickledAccount {
    public var `userId`: String
    public var `deviceId`: String
    public var `pickle`: String
    public var `shared`: Bool
    public var `uploadedSignedKeyCount`: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`userId`: String, `deviceId`: String, `pickle`: String, `shared`: Bool, `uploadedSignedKeyCount`: Int64) {
        self.`userId` = `userId`
        self.`deviceId` = `deviceId`
        self.`pickle` = `pickle`
        self.`shared` = `shared`
        self.`uploadedSignedKeyCount` = `uploadedSignedKeyCount`
    }
}


extension PickledAccount: Equatable, Hashable {
    public static func ==(lhs: PickledAccount, rhs: PickledAccount) -> Bool {
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`deviceId` != rhs.`deviceId` {
            return false
        }
        if lhs.`pickle` != rhs.`pickle` {
            return false
        }
        if lhs.`shared` != rhs.`shared` {
            return false
        }
        if lhs.`uploadedSignedKeyCount` != rhs.`uploadedSignedKeyCount` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`userId`)
        hasher.combine(`deviceId`)
        hasher.combine(`pickle`)
        hasher.combine(`shared`)
        hasher.combine(`uploadedSignedKeyCount`)
    }
}


public struct FfiConverterTypePickledAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PickledAccount {
        return try PickledAccount(
            `userId`: FfiConverterString.read(from: &buf), 
            `deviceId`: FfiConverterString.read(from: &buf), 
            `pickle`: FfiConverterString.read(from: &buf), 
            `shared`: FfiConverterBool.read(from: &buf), 
            `uploadedSignedKeyCount`: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PickledAccount, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterString.write(value.`deviceId`, into: &buf)
        FfiConverterString.write(value.`pickle`, into: &buf)
        FfiConverterBool.write(value.`shared`, into: &buf)
        FfiConverterInt64.write(value.`uploadedSignedKeyCount`, into: &buf)
    }
}


public func FfiConverterTypePickledAccount_lift(_ buf: RustBuffer) throws -> PickledAccount {
    return try FfiConverterTypePickledAccount.lift(buf)
}

public func FfiConverterTypePickledAccount_lower(_ value: PickledAccount) -> RustBuffer {
    return FfiConverterTypePickledAccount.lower(value)
}


public struct PickledInboundGroupSession {
    public var `pickle`: String
    public var `senderKey`: String
    public var `signingKey`: [String: String]
    public var `roomId`: String
    public var `forwardingChains`: [String]
    public var `imported`: Bool
    public var `backedUp`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`pickle`: String, `senderKey`: String, `signingKey`: [String: String], `roomId`: String, `forwardingChains`: [String], `imported`: Bool, `backedUp`: Bool) {
        self.`pickle` = `pickle`
        self.`senderKey` = `senderKey`
        self.`signingKey` = `signingKey`
        self.`roomId` = `roomId`
        self.`forwardingChains` = `forwardingChains`
        self.`imported` = `imported`
        self.`backedUp` = `backedUp`
    }
}


extension PickledInboundGroupSession: Equatable, Hashable {
    public static func ==(lhs: PickledInboundGroupSession, rhs: PickledInboundGroupSession) -> Bool {
        if lhs.`pickle` != rhs.`pickle` {
            return false
        }
        if lhs.`senderKey` != rhs.`senderKey` {
            return false
        }
        if lhs.`signingKey` != rhs.`signingKey` {
            return false
        }
        if lhs.`roomId` != rhs.`roomId` {
            return false
        }
        if lhs.`forwardingChains` != rhs.`forwardingChains` {
            return false
        }
        if lhs.`imported` != rhs.`imported` {
            return false
        }
        if lhs.`backedUp` != rhs.`backedUp` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`pickle`)
        hasher.combine(`senderKey`)
        hasher.combine(`signingKey`)
        hasher.combine(`roomId`)
        hasher.combine(`forwardingChains`)
        hasher.combine(`imported`)
        hasher.combine(`backedUp`)
    }
}


public struct FfiConverterTypePickledInboundGroupSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PickledInboundGroupSession {
        return try PickledInboundGroupSession(
            `pickle`: FfiConverterString.read(from: &buf), 
            `senderKey`: FfiConverterString.read(from: &buf), 
            `signingKey`: FfiConverterDictionaryStringString.read(from: &buf), 
            `roomId`: FfiConverterString.read(from: &buf), 
            `forwardingChains`: FfiConverterSequenceString.read(from: &buf), 
            `imported`: FfiConverterBool.read(from: &buf), 
            `backedUp`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: PickledInboundGroupSession, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`pickle`, into: &buf)
        FfiConverterString.write(value.`senderKey`, into: &buf)
        FfiConverterDictionaryStringString.write(value.`signingKey`, into: &buf)
        FfiConverterString.write(value.`roomId`, into: &buf)
        FfiConverterSequenceString.write(value.`forwardingChains`, into: &buf)
        FfiConverterBool.write(value.`imported`, into: &buf)
        FfiConverterBool.write(value.`backedUp`, into: &buf)
    }
}


public func FfiConverterTypePickledInboundGroupSession_lift(_ buf: RustBuffer) throws -> PickledInboundGroupSession {
    return try FfiConverterTypePickledInboundGroupSession.lift(buf)
}

public func FfiConverterTypePickledInboundGroupSession_lower(_ value: PickledInboundGroupSession) -> RustBuffer {
    return FfiConverterTypePickledInboundGroupSession.lower(value)
}


public struct PickledSession {
    public var `pickle`: String
    public var `senderKey`: String
    public var `createdUsingFallbackKey`: Bool
    public var `creationTime`: String
    public var `lastUseTime`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`pickle`: String, `senderKey`: String, `createdUsingFallbackKey`: Bool, `creationTime`: String, `lastUseTime`: String) {
        self.`pickle` = `pickle`
        self.`senderKey` = `senderKey`
        self.`createdUsingFallbackKey` = `createdUsingFallbackKey`
        self.`creationTime` = `creationTime`
        self.`lastUseTime` = `lastUseTime`
    }
}


extension PickledSession: Equatable, Hashable {
    public static func ==(lhs: PickledSession, rhs: PickledSession) -> Bool {
        if lhs.`pickle` != rhs.`pickle` {
            return false
        }
        if lhs.`senderKey` != rhs.`senderKey` {
            return false
        }
        if lhs.`createdUsingFallbackKey` != rhs.`createdUsingFallbackKey` {
            return false
        }
        if lhs.`creationTime` != rhs.`creationTime` {
            return false
        }
        if lhs.`lastUseTime` != rhs.`lastUseTime` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`pickle`)
        hasher.combine(`senderKey`)
        hasher.combine(`createdUsingFallbackKey`)
        hasher.combine(`creationTime`)
        hasher.combine(`lastUseTime`)
    }
}


public struct FfiConverterTypePickledSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PickledSession {
        return try PickledSession(
            `pickle`: FfiConverterString.read(from: &buf), 
            `senderKey`: FfiConverterString.read(from: &buf), 
            `createdUsingFallbackKey`: FfiConverterBool.read(from: &buf), 
            `creationTime`: FfiConverterString.read(from: &buf), 
            `lastUseTime`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PickledSession, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`pickle`, into: &buf)
        FfiConverterString.write(value.`senderKey`, into: &buf)
        FfiConverterBool.write(value.`createdUsingFallbackKey`, into: &buf)
        FfiConverterString.write(value.`creationTime`, into: &buf)
        FfiConverterString.write(value.`lastUseTime`, into: &buf)
    }
}


public func FfiConverterTypePickledSession_lift(_ buf: RustBuffer) throws -> PickledSession {
    return try FfiConverterTypePickledSession.lift(buf)
}

public func FfiConverterTypePickledSession_lower(_ value: PickledSession) -> RustBuffer {
    return FfiConverterTypePickledSession.lower(value)
}


public struct RequestVerificationResult {
    public var `verification`: VerificationRequest
    public var `request`: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`verification`: VerificationRequest, `request`: OutgoingVerificationRequest) {
        self.`verification` = `verification`
        self.`request` = `request`
    }
}



public struct FfiConverterTypeRequestVerificationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestVerificationResult {
        return try RequestVerificationResult(
            `verification`: FfiConverterTypeVerificationRequest.read(from: &buf), 
            `request`: FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        )
    }

    public static func write(_ value: RequestVerificationResult, into buf: inout [UInt8]) {
        FfiConverterTypeVerificationRequest.write(value.`verification`, into: &buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.`request`, into: &buf)
    }
}


public func FfiConverterTypeRequestVerificationResult_lift(_ buf: RustBuffer) throws -> RequestVerificationResult {
    return try FfiConverterTypeRequestVerificationResult.lift(buf)
}

public func FfiConverterTypeRequestVerificationResult_lower(_ value: RequestVerificationResult) -> RustBuffer {
    return FfiConverterTypeRequestVerificationResult.lower(value)
}


public struct RoomKeyCounts {
    public var `total`: Int64
    public var `backedUp`: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`total`: Int64, `backedUp`: Int64) {
        self.`total` = `total`
        self.`backedUp` = `backedUp`
    }
}


extension RoomKeyCounts: Equatable, Hashable {
    public static func ==(lhs: RoomKeyCounts, rhs: RoomKeyCounts) -> Bool {
        if lhs.`total` != rhs.`total` {
            return false
        }
        if lhs.`backedUp` != rhs.`backedUp` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`total`)
        hasher.combine(`backedUp`)
    }
}


public struct FfiConverterTypeRoomKeyCounts: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomKeyCounts {
        return try RoomKeyCounts(
            `total`: FfiConverterInt64.read(from: &buf), 
            `backedUp`: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoomKeyCounts, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.`total`, into: &buf)
        FfiConverterInt64.write(value.`backedUp`, into: &buf)
    }
}


public func FfiConverterTypeRoomKeyCounts_lift(_ buf: RustBuffer) throws -> RoomKeyCounts {
    return try FfiConverterTypeRoomKeyCounts.lift(buf)
}

public func FfiConverterTypeRoomKeyCounts_lower(_ value: RoomKeyCounts) -> RustBuffer {
    return FfiConverterTypeRoomKeyCounts.lower(value)
}


public struct RoomSettings {
    public var `algorithm`: EventEncryptionAlgorithm
    public var `onlyAllowTrustedDevices`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`algorithm`: EventEncryptionAlgorithm, `onlyAllowTrustedDevices`: Bool) {
        self.`algorithm` = `algorithm`
        self.`onlyAllowTrustedDevices` = `onlyAllowTrustedDevices`
    }
}


extension RoomSettings: Equatable, Hashable {
    public static func ==(lhs: RoomSettings, rhs: RoomSettings) -> Bool {
        if lhs.`algorithm` != rhs.`algorithm` {
            return false
        }
        if lhs.`onlyAllowTrustedDevices` != rhs.`onlyAllowTrustedDevices` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`algorithm`)
        hasher.combine(`onlyAllowTrustedDevices`)
    }
}


public struct FfiConverterTypeRoomSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomSettings {
        return try RoomSettings(
            `algorithm`: FfiConverterTypeEventEncryptionAlgorithm.read(from: &buf), 
            `onlyAllowTrustedDevices`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RoomSettings, into buf: inout [UInt8]) {
        FfiConverterTypeEventEncryptionAlgorithm.write(value.`algorithm`, into: &buf)
        FfiConverterBool.write(value.`onlyAllowTrustedDevices`, into: &buf)
    }
}


public func FfiConverterTypeRoomSettings_lift(_ buf: RustBuffer) throws -> RoomSettings {
    return try FfiConverterTypeRoomSettings.lift(buf)
}

public func FfiConverterTypeRoomSettings_lower(_ value: RoomSettings) -> RustBuffer {
    return FfiConverterTypeRoomSettings.lower(value)
}


public struct ScanResult {
    public var `qr`: QrCode
    public var `request`: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`qr`: QrCode, `request`: OutgoingVerificationRequest) {
        self.`qr` = `qr`
        self.`request` = `request`
    }
}



public struct FfiConverterTypeScanResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScanResult {
        return try ScanResult(
            `qr`: FfiConverterTypeQrCode.read(from: &buf), 
            `request`: FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        )
    }

    public static func write(_ value: ScanResult, into buf: inout [UInt8]) {
        FfiConverterTypeQrCode.write(value.`qr`, into: &buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.`request`, into: &buf)
    }
}


public func FfiConverterTypeScanResult_lift(_ buf: RustBuffer) throws -> ScanResult {
    return try FfiConverterTypeScanResult.lift(buf)
}

public func FfiConverterTypeScanResult_lower(_ value: ScanResult) -> RustBuffer {
    return FfiConverterTypeScanResult.lower(value)
}


public struct SessionMigrationData {
    public var `userId`: String
    public var `deviceId`: String
    public var `curve25519Key`: String
    public var `ed25519Key`: String
    public var `sessions`: [PickledSession]
    public var `inboundGroupSessions`: [PickledInboundGroupSession]
    public var `pickleKey`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`userId`: String, `deviceId`: String, `curve25519Key`: String, `ed25519Key`: String, `sessions`: [PickledSession], `inboundGroupSessions`: [PickledInboundGroupSession], `pickleKey`: [UInt8]) {
        self.`userId` = `userId`
        self.`deviceId` = `deviceId`
        self.`curve25519Key` = `curve25519Key`
        self.`ed25519Key` = `ed25519Key`
        self.`sessions` = `sessions`
        self.`inboundGroupSessions` = `inboundGroupSessions`
        self.`pickleKey` = `pickleKey`
    }
}


extension SessionMigrationData: Equatable, Hashable {
    public static func ==(lhs: SessionMigrationData, rhs: SessionMigrationData) -> Bool {
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`deviceId` != rhs.`deviceId` {
            return false
        }
        if lhs.`curve25519Key` != rhs.`curve25519Key` {
            return false
        }
        if lhs.`ed25519Key` != rhs.`ed25519Key` {
            return false
        }
        if lhs.`sessions` != rhs.`sessions` {
            return false
        }
        if lhs.`inboundGroupSessions` != rhs.`inboundGroupSessions` {
            return false
        }
        if lhs.`pickleKey` != rhs.`pickleKey` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`userId`)
        hasher.combine(`deviceId`)
        hasher.combine(`curve25519Key`)
        hasher.combine(`ed25519Key`)
        hasher.combine(`sessions`)
        hasher.combine(`inboundGroupSessions`)
        hasher.combine(`pickleKey`)
    }
}


public struct FfiConverterTypeSessionMigrationData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionMigrationData {
        return try SessionMigrationData(
            `userId`: FfiConverterString.read(from: &buf), 
            `deviceId`: FfiConverterString.read(from: &buf), 
            `curve25519Key`: FfiConverterString.read(from: &buf), 
            `ed25519Key`: FfiConverterString.read(from: &buf), 
            `sessions`: FfiConverterSequenceTypePickledSession.read(from: &buf), 
            `inboundGroupSessions`: FfiConverterSequenceTypePickledInboundGroupSession.read(from: &buf), 
            `pickleKey`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: SessionMigrationData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterString.write(value.`deviceId`, into: &buf)
        FfiConverterString.write(value.`curve25519Key`, into: &buf)
        FfiConverterString.write(value.`ed25519Key`, into: &buf)
        FfiConverterSequenceTypePickledSession.write(value.`sessions`, into: &buf)
        FfiConverterSequenceTypePickledInboundGroupSession.write(value.`inboundGroupSessions`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`pickleKey`, into: &buf)
    }
}


public func FfiConverterTypeSessionMigrationData_lift(_ buf: RustBuffer) throws -> SessionMigrationData {
    return try FfiConverterTypeSessionMigrationData.lift(buf)
}

public func FfiConverterTypeSessionMigrationData_lower(_ value: SessionMigrationData) -> RustBuffer {
    return FfiConverterTypeSessionMigrationData.lower(value)
}


public struct ShieldState {
    public var `color`: ShieldColor
    public var `message`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`color`: ShieldColor, `message`: String?) {
        self.`color` = `color`
        self.`message` = `message`
    }
}


extension ShieldState: Equatable, Hashable {
    public static func ==(lhs: ShieldState, rhs: ShieldState) -> Bool {
        if lhs.`color` != rhs.`color` {
            return false
        }
        if lhs.`message` != rhs.`message` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`color`)
        hasher.combine(`message`)
    }
}


public struct FfiConverterTypeShieldState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldState {
        return try ShieldState(
            `color`: FfiConverterTypeShieldColor.read(from: &buf), 
            `message`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ShieldState, into buf: inout [UInt8]) {
        FfiConverterTypeShieldColor.write(value.`color`, into: &buf)
        FfiConverterOptionString.write(value.`message`, into: &buf)
    }
}


public func FfiConverterTypeShieldState_lift(_ buf: RustBuffer) throws -> ShieldState {
    return try FfiConverterTypeShieldState.lift(buf)
}

public func FfiConverterTypeShieldState_lower(_ value: ShieldState) -> RustBuffer {
    return FfiConverterTypeShieldState.lower(value)
}


public struct SignatureUploadRequest {
    public var `body`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`body`: String) {
        self.`body` = `body`
    }
}


extension SignatureUploadRequest: Equatable, Hashable {
    public static func ==(lhs: SignatureUploadRequest, rhs: SignatureUploadRequest) -> Bool {
        if lhs.`body` != rhs.`body` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`body`)
    }
}


public struct FfiConverterTypeSignatureUploadRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureUploadRequest {
        return try SignatureUploadRequest(
            `body`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureUploadRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`body`, into: &buf)
    }
}


public func FfiConverterTypeSignatureUploadRequest_lift(_ buf: RustBuffer) throws -> SignatureUploadRequest {
    return try FfiConverterTypeSignatureUploadRequest.lift(buf)
}

public func FfiConverterTypeSignatureUploadRequest_lower(_ value: SignatureUploadRequest) -> RustBuffer {
    return FfiConverterTypeSignatureUploadRequest.lower(value)
}


public struct SignatureVerification {
    public var `deviceSignature`: SignatureState
    public var `userIdentitySignature`: SignatureState
    public var `otherDevicesSignatures`: [String: SignatureState]
    public var `trusted`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`deviceSignature`: SignatureState, `userIdentitySignature`: SignatureState, `otherDevicesSignatures`: [String: SignatureState], `trusted`: Bool) {
        self.`deviceSignature` = `deviceSignature`
        self.`userIdentitySignature` = `userIdentitySignature`
        self.`otherDevicesSignatures` = `otherDevicesSignatures`
        self.`trusted` = `trusted`
    }
}


extension SignatureVerification: Equatable, Hashable {
    public static func ==(lhs: SignatureVerification, rhs: SignatureVerification) -> Bool {
        if lhs.`deviceSignature` != rhs.`deviceSignature` {
            return false
        }
        if lhs.`userIdentitySignature` != rhs.`userIdentitySignature` {
            return false
        }
        if lhs.`otherDevicesSignatures` != rhs.`otherDevicesSignatures` {
            return false
        }
        if lhs.`trusted` != rhs.`trusted` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`deviceSignature`)
        hasher.combine(`userIdentitySignature`)
        hasher.combine(`otherDevicesSignatures`)
        hasher.combine(`trusted`)
    }
}


public struct FfiConverterTypeSignatureVerification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureVerification {
        return try SignatureVerification(
            `deviceSignature`: FfiConverterTypeSignatureState.read(from: &buf), 
            `userIdentitySignature`: FfiConverterTypeSignatureState.read(from: &buf), 
            `otherDevicesSignatures`: FfiConverterDictionaryStringTypeSignatureState.read(from: &buf), 
            `trusted`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureVerification, into buf: inout [UInt8]) {
        FfiConverterTypeSignatureState.write(value.`deviceSignature`, into: &buf)
        FfiConverterTypeSignatureState.write(value.`userIdentitySignature`, into: &buf)
        FfiConverterDictionaryStringTypeSignatureState.write(value.`otherDevicesSignatures`, into: &buf)
        FfiConverterBool.write(value.`trusted`, into: &buf)
    }
}


public func FfiConverterTypeSignatureVerification_lift(_ buf: RustBuffer) throws -> SignatureVerification {
    return try FfiConverterTypeSignatureVerification.lift(buf)
}

public func FfiConverterTypeSignatureVerification_lower(_ value: SignatureVerification) -> RustBuffer {
    return FfiConverterTypeSignatureVerification.lower(value)
}


public struct StartSasResult {
    public var `sas`: Sas
    public var `request`: OutgoingVerificationRequest

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`sas`: Sas, `request`: OutgoingVerificationRequest) {
        self.`sas` = `sas`
        self.`request` = `request`
    }
}



public struct FfiConverterTypeStartSasResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StartSasResult {
        return try StartSasResult(
            `sas`: FfiConverterTypeSas.read(from: &buf), 
            `request`: FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        )
    }

    public static func write(_ value: StartSasResult, into buf: inout [UInt8]) {
        FfiConverterTypeSas.write(value.`sas`, into: &buf)
        FfiConverterTypeOutgoingVerificationRequest.write(value.`request`, into: &buf)
    }
}


public func FfiConverterTypeStartSasResult_lift(_ buf: RustBuffer) throws -> StartSasResult {
    return try FfiConverterTypeStartSasResult.lift(buf)
}

public func FfiConverterTypeStartSasResult_lower(_ value: StartSasResult) -> RustBuffer {
    return FfiConverterTypeStartSasResult.lower(value)
}


public struct UploadSigningKeysRequest {
    public var `masterKey`: String
    public var `selfSigningKey`: String
    public var `userSigningKey`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`masterKey`: String, `selfSigningKey`: String, `userSigningKey`: String) {
        self.`masterKey` = `masterKey`
        self.`selfSigningKey` = `selfSigningKey`
        self.`userSigningKey` = `userSigningKey`
    }
}


extension UploadSigningKeysRequest: Equatable, Hashable {
    public static func ==(lhs: UploadSigningKeysRequest, rhs: UploadSigningKeysRequest) -> Bool {
        if lhs.`masterKey` != rhs.`masterKey` {
            return false
        }
        if lhs.`selfSigningKey` != rhs.`selfSigningKey` {
            return false
        }
        if lhs.`userSigningKey` != rhs.`userSigningKey` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`masterKey`)
        hasher.combine(`selfSigningKey`)
        hasher.combine(`userSigningKey`)
    }
}


public struct FfiConverterTypeUploadSigningKeysRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadSigningKeysRequest {
        return try UploadSigningKeysRequest(
            `masterKey`: FfiConverterString.read(from: &buf), 
            `selfSigningKey`: FfiConverterString.read(from: &buf), 
            `userSigningKey`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UploadSigningKeysRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`masterKey`, into: &buf)
        FfiConverterString.write(value.`selfSigningKey`, into: &buf)
        FfiConverterString.write(value.`userSigningKey`, into: &buf)
    }
}


public func FfiConverterTypeUploadSigningKeysRequest_lift(_ buf: RustBuffer) throws -> UploadSigningKeysRequest {
    return try FfiConverterTypeUploadSigningKeysRequest.lift(buf)
}

public func FfiConverterTypeUploadSigningKeysRequest_lower(_ value: UploadSigningKeysRequest) -> RustBuffer {
    return FfiConverterTypeUploadSigningKeysRequest.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EventEncryptionAlgorithm {
    
    case `olmV1Curve25519AesSha2`
    case `megolmV1AesSha2`
}

public struct FfiConverterTypeEventEncryptionAlgorithm: FfiConverterRustBuffer {
    typealias SwiftType = EventEncryptionAlgorithm

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventEncryptionAlgorithm {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`olmV1Curve25519AesSha2`
        
        case 2: return .`megolmV1AesSha2`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventEncryptionAlgorithm, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`olmV1Curve25519AesSha2`:
            writeInt(&buf, Int32(1))
        
        
        case .`megolmV1AesSha2`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeEventEncryptionAlgorithm_lift(_ buf: RustBuffer) throws -> EventEncryptionAlgorithm {
    return try FfiConverterTypeEventEncryptionAlgorithm.lift(buf)
}

public func FfiConverterTypeEventEncryptionAlgorithm_lower(_ value: EventEncryptionAlgorithm) -> RustBuffer {
    return FfiConverterTypeEventEncryptionAlgorithm.lower(value)
}


extension EventEncryptionAlgorithm: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum HistoryVisibility {
    
    case `invited`
    case `joined`
    case `shared`
    case `worldReadable`
}

public struct FfiConverterTypeHistoryVisibility: FfiConverterRustBuffer {
    typealias SwiftType = HistoryVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoryVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`invited`
        
        case 2: return .`joined`
        
        case 3: return .`shared`
        
        case 4: return .`worldReadable`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HistoryVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`invited`:
            writeInt(&buf, Int32(1))
        
        
        case .`joined`:
            writeInt(&buf, Int32(2))
        
        
        case .`shared`:
            writeInt(&buf, Int32(3))
        
        
        case .`worldReadable`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeHistoryVisibility_lift(_ buf: RustBuffer) throws -> HistoryVisibility {
    return try FfiConverterTypeHistoryVisibility.lift(buf)
}

public func FfiConverterTypeHistoryVisibility_lower(_ value: HistoryVisibility) -> RustBuffer {
    return FfiConverterTypeHistoryVisibility.lower(value)
}


extension HistoryVisibility: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LocalTrust {
    
    case `verified`
    case `blackListed`
    case `ignored`
    case `unset`
}

public struct FfiConverterTypeLocalTrust: FfiConverterRustBuffer {
    typealias SwiftType = LocalTrust

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalTrust {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`verified`
        
        case 2: return .`blackListed`
        
        case 3: return .`ignored`
        
        case 4: return .`unset`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LocalTrust, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`verified`:
            writeInt(&buf, Int32(1))
        
        
        case .`blackListed`:
            writeInt(&buf, Int32(2))
        
        
        case .`ignored`:
            writeInt(&buf, Int32(3))
        
        
        case .`unset`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeLocalTrust_lift(_ buf: RustBuffer) throws -> LocalTrust {
    return try FfiConverterTypeLocalTrust.lift(buf)
}

public func FfiConverterTypeLocalTrust_lower(_ value: LocalTrust) -> RustBuffer {
    return FfiConverterTypeLocalTrust.lower(value)
}


extension LocalTrust: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum OutgoingVerificationRequest {
    
    case `toDevice`(`requestId`: String, `eventType`: String, `body`: String)
    case `inRoom`(`requestId`: String, `roomId`: String, `eventType`: String, `content`: String)
}

public struct FfiConverterTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingVerificationRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutgoingVerificationRequest {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`toDevice`(
            `requestId`: try FfiConverterString.read(from: &buf), 
            `eventType`: try FfiConverterString.read(from: &buf), 
            `body`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`inRoom`(
            `requestId`: try FfiConverterString.read(from: &buf), 
            `roomId`: try FfiConverterString.read(from: &buf), 
            `eventType`: try FfiConverterString.read(from: &buf), 
            `content`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OutgoingVerificationRequest, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`toDevice`(`requestId`,`eventType`,`body`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`requestId`, into: &buf)
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`body`, into: &buf)
            
        
        case let .`inRoom`(`requestId`,`roomId`,`eventType`,`content`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`requestId`, into: &buf)
            FfiConverterString.write(`roomId`, into: &buf)
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`content`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeOutgoingVerificationRequest_lift(_ buf: RustBuffer) throws -> OutgoingVerificationRequest {
    return try FfiConverterTypeOutgoingVerificationRequest.lift(buf)
}

public func FfiConverterTypeOutgoingVerificationRequest_lower(_ value: OutgoingVerificationRequest) -> RustBuffer {
    return FfiConverterTypeOutgoingVerificationRequest.lower(value)
}


extension OutgoingVerificationRequest: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum QrCodeState {
    
    case `started`
    case `scanned`
    case `confirmed`
    case `reciprocated`
    case `done`
    case `cancelled`(`cancelInfo`: CancelInfo)
}

public struct FfiConverterTypeQrCodeState: FfiConverterRustBuffer {
    typealias SwiftType = QrCodeState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCodeState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`started`
        
        case 2: return .`scanned`
        
        case 3: return .`confirmed`
        
        case 4: return .`reciprocated`
        
        case 5: return .`done`
        
        case 6: return .`cancelled`(
            `cancelInfo`: try FfiConverterTypeCancelInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrCodeState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`started`:
            writeInt(&buf, Int32(1))
        
        
        case .`scanned`:
            writeInt(&buf, Int32(2))
        
        
        case .`confirmed`:
            writeInt(&buf, Int32(3))
        
        
        case .`reciprocated`:
            writeInt(&buf, Int32(4))
        
        
        case .`done`:
            writeInt(&buf, Int32(5))
        
        
        case let .`cancelled`(`cancelInfo`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeCancelInfo.write(`cancelInfo`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeQrCodeState_lift(_ buf: RustBuffer) throws -> QrCodeState {
    return try FfiConverterTypeQrCodeState.lift(buf)
}

public func FfiConverterTypeQrCodeState_lower(_ value: QrCodeState) -> RustBuffer {
    return FfiConverterTypeQrCodeState.lower(value)
}


extension QrCodeState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Request {
    
    case `toDevice`(`requestId`: String, `eventType`: String, `body`: String)
    case `keysUpload`(`requestId`: String, `body`: String)
    case `keysQuery`(`requestId`: String, `users`: [String])
    case `keysClaim`(`requestId`: String, `oneTimeKeys`: [String: [String: String]])
    case `keysBackup`(`requestId`: String, `version`: String, `rooms`: String)
    case `roomMessage`(`requestId`: String, `roomId`: String, `eventType`: String, `content`: String)
    case `signatureUpload`(`requestId`: String, `body`: String)
}

public struct FfiConverterTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = Request

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Request {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`toDevice`(
            `requestId`: try FfiConverterString.read(from: &buf), 
            `eventType`: try FfiConverterString.read(from: &buf), 
            `body`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`keysUpload`(
            `requestId`: try FfiConverterString.read(from: &buf), 
            `body`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`keysQuery`(
            `requestId`: try FfiConverterString.read(from: &buf), 
            `users`: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 4: return .`keysClaim`(
            `requestId`: try FfiConverterString.read(from: &buf), 
            `oneTimeKeys`: try FfiConverterDictionaryStringDictionaryStringString.read(from: &buf)
        )
        
        case 5: return .`keysBackup`(
            `requestId`: try FfiConverterString.read(from: &buf), 
            `version`: try FfiConverterString.read(from: &buf), 
            `rooms`: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .`roomMessage`(
            `requestId`: try FfiConverterString.read(from: &buf), 
            `roomId`: try FfiConverterString.read(from: &buf), 
            `eventType`: try FfiConverterString.read(from: &buf), 
            `content`: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .`signatureUpload`(
            `requestId`: try FfiConverterString.read(from: &buf), 
            `body`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Request, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`toDevice`(`requestId`,`eventType`,`body`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`requestId`, into: &buf)
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`body`, into: &buf)
            
        
        case let .`keysUpload`(`requestId`,`body`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`requestId`, into: &buf)
            FfiConverterString.write(`body`, into: &buf)
            
        
        case let .`keysQuery`(`requestId`,`users`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`requestId`, into: &buf)
            FfiConverterSequenceString.write(`users`, into: &buf)
            
        
        case let .`keysClaim`(`requestId`,`oneTimeKeys`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`requestId`, into: &buf)
            FfiConverterDictionaryStringDictionaryStringString.write(`oneTimeKeys`, into: &buf)
            
        
        case let .`keysBackup`(`requestId`,`version`,`rooms`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`requestId`, into: &buf)
            FfiConverterString.write(`version`, into: &buf)
            FfiConverterString.write(`rooms`, into: &buf)
            
        
        case let .`roomMessage`(`requestId`,`roomId`,`eventType`,`content`):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(`requestId`, into: &buf)
            FfiConverterString.write(`roomId`, into: &buf)
            FfiConverterString.write(`eventType`, into: &buf)
            FfiConverterString.write(`content`, into: &buf)
            
        
        case let .`signatureUpload`(`requestId`,`body`):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(`requestId`, into: &buf)
            FfiConverterString.write(`body`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRequest_lift(_ buf: RustBuffer) throws -> Request {
    return try FfiConverterTypeRequest.lift(buf)
}

public func FfiConverterTypeRequest_lower(_ value: Request) -> RustBuffer {
    return FfiConverterTypeRequest.lower(value)
}


extension Request: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RequestType {
    
    case `keysQuery`
    case `keysClaim`
    case `keysUpload`
    case `toDevice`
    case `signatureUpload`
    case `keysBackup`
    case `roomMessage`
}

public struct FfiConverterTypeRequestType: FfiConverterRustBuffer {
    typealias SwiftType = RequestType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`keysQuery`
        
        case 2: return .`keysClaim`
        
        case 3: return .`keysUpload`
        
        case 4: return .`toDevice`
        
        case 5: return .`signatureUpload`
        
        case 6: return .`keysBackup`
        
        case 7: return .`roomMessage`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`keysQuery`:
            writeInt(&buf, Int32(1))
        
        
        case .`keysClaim`:
            writeInt(&buf, Int32(2))
        
        
        case .`keysUpload`:
            writeInt(&buf, Int32(3))
        
        
        case .`toDevice`:
            writeInt(&buf, Int32(4))
        
        
        case .`signatureUpload`:
            writeInt(&buf, Int32(5))
        
        
        case .`keysBackup`:
            writeInt(&buf, Int32(6))
        
        
        case .`roomMessage`:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeRequestType_lift(_ buf: RustBuffer) throws -> RequestType {
    return try FfiConverterTypeRequestType.lift(buf)
}

public func FfiConverterTypeRequestType_lower(_ value: RequestType) -> RustBuffer {
    return FfiConverterTypeRequestType.lower(value)
}


extension RequestType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SasState {
    
    case `started`
    case `accepted`
    case `keysExchanged`(`emojis`: [Int32]?, `decimals`: [Int32])
    case `confirmed`
    case `done`
    case `cancelled`(`cancelInfo`: CancelInfo)
}

public struct FfiConverterTypeSasState: FfiConverterRustBuffer {
    typealias SwiftType = SasState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SasState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`started`
        
        case 2: return .`accepted`
        
        case 3: return .`keysExchanged`(
            `emojis`: try FfiConverterOptionSequenceInt32.read(from: &buf), 
            `decimals`: try FfiConverterSequenceInt32.read(from: &buf)
        )
        
        case 4: return .`confirmed`
        
        case 5: return .`done`
        
        case 6: return .`cancelled`(
            `cancelInfo`: try FfiConverterTypeCancelInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SasState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`started`:
            writeInt(&buf, Int32(1))
        
        
        case .`accepted`:
            writeInt(&buf, Int32(2))
        
        
        case let .`keysExchanged`(`emojis`,`decimals`):
            writeInt(&buf, Int32(3))
            FfiConverterOptionSequenceInt32.write(`emojis`, into: &buf)
            FfiConverterSequenceInt32.write(`decimals`, into: &buf)
            
        
        case .`confirmed`:
            writeInt(&buf, Int32(4))
        
        
        case .`done`:
            writeInt(&buf, Int32(5))
        
        
        case let .`cancelled`(`cancelInfo`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeCancelInfo.write(`cancelInfo`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSasState_lift(_ buf: RustBuffer) throws -> SasState {
    return try FfiConverterTypeSasState.lift(buf)
}

public func FfiConverterTypeSasState_lower(_ value: SasState) -> RustBuffer {
    return FfiConverterTypeSasState.lower(value)
}


extension SasState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ShieldColor {
    
    case `red`
    case `grey`
    case `none`
}

public struct FfiConverterTypeShieldColor: FfiConverterRustBuffer {
    typealias SwiftType = ShieldColor

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldColor {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`red`
        
        case 2: return .`grey`
        
        case 3: return .`none`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShieldColor, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`red`:
            writeInt(&buf, Int32(1))
        
        
        case .`grey`:
            writeInt(&buf, Int32(2))
        
        
        case .`none`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeShieldColor_lift(_ buf: RustBuffer) throws -> ShieldColor {
    return try FfiConverterTypeShieldColor.lift(buf)
}

public func FfiConverterTypeShieldColor_lower(_ value: ShieldColor) -> RustBuffer {
    return FfiConverterTypeShieldColor.lower(value)
}


extension ShieldColor: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SignatureState {
    
    case `missing`
    case `invalid`
    case `validButNotTrusted`
    case `validAndTrusted`
}

public struct FfiConverterTypeSignatureState: FfiConverterRustBuffer {
    typealias SwiftType = SignatureState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`missing`
        
        case 2: return .`invalid`
        
        case 3: return .`validButNotTrusted`
        
        case 4: return .`validAndTrusted`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`missing`:
            writeInt(&buf, Int32(1))
        
        
        case .`invalid`:
            writeInt(&buf, Int32(2))
        
        
        case .`validButNotTrusted`:
            writeInt(&buf, Int32(3))
        
        
        case .`validAndTrusted`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeSignatureState_lift(_ buf: RustBuffer) throws -> SignatureState {
    return try FfiConverterTypeSignatureState.lift(buf)
}

public func FfiConverterTypeSignatureState_lower(_ value: SignatureState) -> RustBuffer {
    return FfiConverterTypeSignatureState.lower(value)
}


extension SignatureState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum UserIdentity {
    
    case `own`(`userId`: String, `trustsOurOwnDevice`: Bool, `masterKey`: String, `selfSigningKey`: String, `userSigningKey`: String)
    case `other`(`userId`: String, `masterKey`: String, `selfSigningKey`: String)
}

public struct FfiConverterTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserIdentity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`own`(
            `userId`: try FfiConverterString.read(from: &buf), 
            `trustsOurOwnDevice`: try FfiConverterBool.read(from: &buf), 
            `masterKey`: try FfiConverterString.read(from: &buf), 
            `selfSigningKey`: try FfiConverterString.read(from: &buf), 
            `userSigningKey`: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .`other`(
            `userId`: try FfiConverterString.read(from: &buf), 
            `masterKey`: try FfiConverterString.read(from: &buf), 
            `selfSigningKey`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UserIdentity, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`own`(`userId`,`trustsOurOwnDevice`,`masterKey`,`selfSigningKey`,`userSigningKey`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`userId`, into: &buf)
            FfiConverterBool.write(`trustsOurOwnDevice`, into: &buf)
            FfiConverterString.write(`masterKey`, into: &buf)
            FfiConverterString.write(`selfSigningKey`, into: &buf)
            FfiConverterString.write(`userSigningKey`, into: &buf)
            
        
        case let .`other`(`userId`,`masterKey`,`selfSigningKey`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`userId`, into: &buf)
            FfiConverterString.write(`masterKey`, into: &buf)
            FfiConverterString.write(`selfSigningKey`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeUserIdentity_lift(_ buf: RustBuffer) throws -> UserIdentity {
    return try FfiConverterTypeUserIdentity.lift(buf)
}

public func FfiConverterTypeUserIdentity_lower(_ value: UserIdentity) -> RustBuffer {
    return FfiConverterTypeUserIdentity.lower(value)
}


extension UserIdentity: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum VerificationRequestState {
    
    case `requested`
    case `ready`(`theirMethods`: [String], `ourMethods`: [String])
    case `done`
    case `cancelled`(`cancelInfo`: CancelInfo)
}

public struct FfiConverterTypeVerificationRequestState: FfiConverterRustBuffer {
    typealias SwiftType = VerificationRequestState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationRequestState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`requested`
        
        case 2: return .`ready`(
            `theirMethods`: try FfiConverterSequenceString.read(from: &buf), 
            `ourMethods`: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 3: return .`done`
        
        case 4: return .`cancelled`(
            `cancelInfo`: try FfiConverterTypeCancelInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerificationRequestState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`requested`:
            writeInt(&buf, Int32(1))
        
        
        case let .`ready`(`theirMethods`,`ourMethods`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceString.write(`theirMethods`, into: &buf)
            FfiConverterSequenceString.write(`ourMethods`, into: &buf)
            
        
        case .`done`:
            writeInt(&buf, Int32(3))
        
        
        case let .`cancelled`(`cancelInfo`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeCancelInfo.write(`cancelInfo`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeVerificationRequestState_lift(_ buf: RustBuffer) throws -> VerificationRequestState {
    return try FfiConverterTypeVerificationRequestState.lift(buf)
}

public func FfiConverterTypeVerificationRequestState_lower(_ value: VerificationRequestState) -> RustBuffer {
    return FfiConverterTypeVerificationRequestState.lower(value)
}


extension VerificationRequestState: Equatable, Hashable {}



public enum CryptoStoreError {

    
    
    // Simple error enums only carry a message
    case OpenStore(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case OlmError(message: String)
    
    // Simple error enums only carry a message
    case Serialization(message: String)
    
    // Simple error enums only carry a message
    case InvalidUserId(message: String)
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
}

public struct FfiConverterTypeCryptoStoreError: FfiConverterRustBuffer {
    typealias SwiftType = CryptoStoreError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CryptoStoreError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .OpenStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .OlmError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Serialization(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidUserId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .Identifier(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CryptoStoreError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .OpenStore(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .CryptoStore(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .OlmError(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .Serialization(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidUserId(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
        case let .Identifier(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension CryptoStoreError: Equatable, Hashable {}

extension CryptoStoreError: Error { }


public enum DecodeError {

    
    
    // Simple error enums only carry a message
    case Decode(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
}

public struct FfiConverterTypeDecodeError: FfiConverterRustBuffer {
    typealias SwiftType = DecodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Decode(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodeError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Decode(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .CryptoStore(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension DecodeError: Equatable, Hashable {}

extension DecodeError: Error { }


public enum DecryptionError {

    
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
    // Simple error enums only carry a message
    case Serialization(message: String)
    
    // Simple error enums only carry a message
    case Megolm(message: String)
    
    // Simple error enums only carry a message
    case MissingRoomKey(message: String)
    
    // Simple error enums only carry a message
    case Store(message: String)
    
}

public struct FfiConverterTypeDecryptionError: FfiConverterRustBuffer {
    typealias SwiftType = DecryptionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Identifier(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Serialization(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Megolm(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .MissingRoomKey(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .Store(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecryptionError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Identifier(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .Serialization(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .Megolm(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .MissingRoomKey(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .Store(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension DecryptionError: Equatable, Hashable {}

extension DecryptionError: Error { }


public enum KeyImportError {

    
    
    // Simple error enums only carry a message
    case Export(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case Json(message: String)
    
}

public struct FfiConverterTypeKeyImportError: FfiConverterRustBuffer {
    typealias SwiftType = KeyImportError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyImportError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Export(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Json(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeyImportError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Export(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .CryptoStore(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .Json(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension KeyImportError: Equatable, Hashable {}

extension KeyImportError: Error { }


public enum MigrationError {

    
    
    case Generic(`errorMessage`: String)
}

public struct FfiConverterTypeMigrationError: FfiConverterRustBuffer {
    typealias SwiftType = MigrationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MigrationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            `errorMessage`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MigrationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(`errorMessage`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`errorMessage`, into: &buf)
            
        }
    }
}


extension MigrationError: Equatable, Hashable {}

extension MigrationError: Error { }


public enum PkDecryptionError {

    
    
    // Simple error enums only carry a message
    case Olm(message: String)
    
}

public struct FfiConverterTypePkDecryptionError: FfiConverterRustBuffer {
    typealias SwiftType = PkDecryptionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PkDecryptionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Olm(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PkDecryptionError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Olm(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension PkDecryptionError: Equatable, Hashable {}

extension PkDecryptionError: Error { }


public enum SecretImportError {

    
    
    // Simple error enums only carry a message
    case Import(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
}

public struct FfiConverterTypeSecretImportError: FfiConverterRustBuffer {
    typealias SwiftType = SecretImportError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretImportError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Import(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecretImportError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Import(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .CryptoStore(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension SecretImportError: Equatable, Hashable {}

extension SecretImportError: Error { }


public enum SignatureError {

    
    
    // Simple error enums only carry a message
    case Signature(message: String)
    
    // Simple error enums only carry a message
    case Identifier(message: String)
    
    // Simple error enums only carry a message
    case CryptoStore(message: String)
    
    // Simple error enums only carry a message
    case UnknownDevice(message: String)
    
    // Simple error enums only carry a message
    case UnknownUserIdentity(message: String)
    
}

public struct FfiConverterTypeSignatureError: FfiConverterRustBuffer {
    typealias SwiftType = SignatureError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Signature(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Identifier(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .CryptoStore(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .UnknownDevice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .UnknownUserIdentity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Signature(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .Identifier(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .CryptoStore(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .UnknownDevice(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .UnknownUserIdentity(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension SignatureError: Equatable, Hashable {}

extension SignatureError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for Logger Callback Interface

public protocol Logger : AnyObject {
    func `log`(`logLine`: String) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceLogger : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeLog`(_ swiftCallbackInterface: Logger, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`log`(
                    `logLine`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceLogger.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: Logger
            do {
                cb = try FfiConverterCallbackInterfaceLogger.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Logger: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeLog`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceLogger {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_crypto_ffi_f611_Logger_init_callback(foreignCallbackCallbackInterfaceLogger, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<Logger>()
}

extension FfiConverterCallbackInterfaceLogger : FfiConverter {
    typealias SwiftType = Logger
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for ProgressListener Callback Interface

public protocol ProgressListener : AnyObject {
    func `onProgress`(`progress`: Int32, `total`: Int32) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceProgressListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeOnProgress`(_ swiftCallbackInterface: ProgressListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onProgress`(
                    `progress`:  try FfiConverterInt32.read(from: &reader), 
                    `total`:  try FfiConverterInt32.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceProgressListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: ProgressListener
            do {
                cb = try FfiConverterCallbackInterfaceProgressListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("ProgressListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnProgress`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceProgressListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_crypto_ffi_f611_ProgressListener_init_callback(foreignCallbackCallbackInterfaceProgressListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<ProgressListener>()
}

extension FfiConverterCallbackInterfaceProgressListener : FfiConverter {
    typealias SwiftType = ProgressListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for QrCodeListener Callback Interface

public protocol QrCodeListener : AnyObject {
    func `onChange`(`state`: QrCodeState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceQrCodeListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeOnChange`(_ swiftCallbackInterface: QrCodeListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onChange`(
                    `state`:  try FfiConverterTypeQrCodeState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceQrCodeListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: QrCodeListener
            do {
                cb = try FfiConverterCallbackInterfaceQrCodeListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("QrCodeListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnChange`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceQrCodeListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_crypto_ffi_f611_QrCodeListener_init_callback(foreignCallbackCallbackInterfaceQrCodeListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<QrCodeListener>()
}

extension FfiConverterCallbackInterfaceQrCodeListener : FfiConverter {
    typealias SwiftType = QrCodeListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SasListener Callback Interface

public protocol SasListener : AnyObject {
    func `onChange`(`state`: SasState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSasListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeOnChange`(_ swiftCallbackInterface: SasListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onChange`(
                    `state`:  try FfiConverterTypeSasState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSasListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SasListener
            do {
                cb = try FfiConverterCallbackInterfaceSasListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SasListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnChange`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSasListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_crypto_ffi_f611_SasListener_init_callback(foreignCallbackCallbackInterfaceSasListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SasListener>()
}

extension FfiConverterCallbackInterfaceSasListener : FfiConverter {
    typealias SwiftType = SasListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for VerificationRequestListener Callback Interface

public protocol VerificationRequestListener : AnyObject {
    func `onChange`(`state`: VerificationRequestState) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceVerificationRequestListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeOnChange`(_ swiftCallbackInterface: VerificationRequestListener, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onChange`(
                    `state`:  try FfiConverterTypeVerificationRequestState.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceVerificationRequestListener.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: VerificationRequestListener
            do {
                cb = try FfiConverterCallbackInterfaceVerificationRequestListener.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("VerificationRequestListener: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnChange`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceVerificationRequestListener {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            ffi_matrix_sdk_crypto_ffi_f611_VerificationRequestListener_init_callback(foreignCallbackCallbackInterfaceVerificationRequestListener, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<VerificationRequestListener>()
}

extension FfiConverterCallbackInterfaceVerificationRequestListener : FfiConverter {
    typealias SwiftType = VerificationRequestListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBackupKeys: FfiConverterRustBuffer {
    typealias SwiftType = BackupKeys?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBackupKeys.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackupKeys.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBackupRecoveryKey: FfiConverterRustBuffer {
    typealias SwiftType = BackupRecoveryKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBackupRecoveryKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackupRecoveryKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeQrCode: FfiConverterRustBuffer {
    typealias SwiftType = QrCode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeQrCode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeQrCode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSas: FfiConverterRustBuffer {
    typealias SwiftType = Sas?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSas.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSas.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVerification: FfiConverterRustBuffer {
    typealias SwiftType = Verification?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVerification.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVerification.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = VerificationRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVerificationRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVerificationRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCancelInfo: FfiConverterRustBuffer {
    typealias SwiftType = CancelInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCancelInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCancelInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeConfirmVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = ConfirmVerificationResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConfirmVerificationResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConfirmVerificationResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCrossSigningKeyExport: FfiConverterRustBuffer {
    typealias SwiftType = CrossSigningKeyExport?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCrossSigningKeyExport.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCrossSigningKeyExport.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDevice: FfiConverterRustBuffer {
    typealias SwiftType = Device?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDevice.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDevice.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePassphraseInfo: FfiConverterRustBuffer {
    typealias SwiftType = PassphraseInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePassphraseInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePassphraseInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRequestVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = RequestVerificationResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequestVerificationResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequestVerificationResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRoomSettings: FfiConverterRustBuffer {
    typealias SwiftType = RoomSettings?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomSettings.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomSettings.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeScanResult: FfiConverterRustBuffer {
    typealias SwiftType = ScanResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeScanResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeScanResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSignatureUploadRequest: FfiConverterRustBuffer {
    typealias SwiftType = SignatureUploadRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSignatureUploadRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignatureUploadRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeStartSasResult: FfiConverterRustBuffer {
    typealias SwiftType = StartSasResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeStartSasResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeStartSasResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = OutgoingVerificationRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutgoingVerificationRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutgoingVerificationRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = Request?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserIdentity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserIdentity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceInt32: FfiConverterRustBuffer {
    typealias SwiftType = [Int32]

    public static func write(_ value: [Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int32] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = [VerificationRequest]

    public static func write(_ value: [VerificationRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeVerificationRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [VerificationRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [VerificationRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeVerificationRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDevice: FfiConverterRustBuffer {
    typealias SwiftType = [Device]

    public static func write(_ value: [Device], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDevice.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Device] {
        let len: Int32 = try readInt(&buf)
        var seq = [Device]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDevice.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePickledInboundGroupSession: FfiConverterRustBuffer {
    typealias SwiftType = [PickledInboundGroupSession]

    public static func write(_ value: [PickledInboundGroupSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePickledInboundGroupSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PickledInboundGroupSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [PickledInboundGroupSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePickledInboundGroupSession.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePickledSession: FfiConverterRustBuffer {
    typealias SwiftType = [PickledSession]

    public static func write(_ value: [PickledSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePickledSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PickledSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [PickledSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePickledSession.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOutgoingVerificationRequest: FfiConverterRustBuffer {
    typealias SwiftType = [OutgoingVerificationRequest]

    public static func write(_ value: [OutgoingVerificationRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOutgoingVerificationRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OutgoingVerificationRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [OutgoingVerificationRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOutgoingVerificationRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRequest: FfiConverterRustBuffer {
    typealias SwiftType = [Request]

    public static func write(_ value: [Request], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Request] {
        let len: Int32 = try readInt(&buf)
        var seq = [Request]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequest.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringInt32: FfiConverterRustBuffer {
    public static func write(_ value: [String: Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterInt32.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Int32] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Int32]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterInt32.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeRoomSettings: FfiConverterRustBuffer {
    public static func write(_ value: [String: RoomSettings], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeRoomSettings.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: RoomSettings] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: RoomSettings]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeRoomSettings.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeSignatureState: FfiConverterRustBuffer {
    public static func write(_ value: [String: SignatureState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeSignatureState.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: SignatureState] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: SignatureState]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeSignatureState.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: [String]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: [String]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: [String]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func `setLogger`(`logger`: Logger)  {
    try! rustCall() {
    matrix_sdk_crypto_ffi_f611_set_logger(
        FfiConverterCallbackInterfaceLogger.lower(`logger`), $0)
}
}



public func `migrate`(`data`: MigrationData, `path`: String, `passphrase`: String?, `progressListener`: ProgressListener) throws {
    try rustCallWithError(FfiConverterTypeMigrationError.self) {
    matrix_sdk_crypto_ffi_f611_migrate(
        FfiConverterTypeMigrationData.lower(`data`), 
        FfiConverterString.lower(`path`), 
        FfiConverterOptionString.lower(`passphrase`), 
        FfiConverterCallbackInterfaceProgressListener.lower(`progressListener`), $0)
}
}



public func `migrateSessions`(`data`: SessionMigrationData, `path`: String, `passphrase`: String?, `progressListener`: ProgressListener) throws {
    try rustCallWithError(FfiConverterTypeMigrationError.self) {
    matrix_sdk_crypto_ffi_f611_migrate_sessions(
        FfiConverterTypeSessionMigrationData.lower(`data`), 
        FfiConverterString.lower(`path`), 
        FfiConverterOptionString.lower(`passphrase`), 
        FfiConverterCallbackInterfaceProgressListener.lower(`progressListener`), $0)
}
}



public func `migrateRoomSettings`(`roomSettings`: [String: RoomSettings], `path`: String, `passphrase`: String?) throws {
    try rustCallWithError(FfiConverterTypeMigrationError.self) {
    matrix_sdk_crypto_ffi_f611_migrate_room_settings(
        FfiConverterDictionaryStringTypeRoomSettings.lower(`roomSettings`), 
        FfiConverterString.lower(`path`), 
        FfiConverterOptionString.lower(`passphrase`), $0)
}
}



public func `version`()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    _uniffi_matrix_sdk_crypto_ffi_version_364($0)
}
    )
}

public func `vodozemacVersion`()  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    _uniffi_matrix_sdk_crypto_ffi_vodozemac_version_48d4($0)
}
    )
}

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum MatrixSdkCryptoLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}